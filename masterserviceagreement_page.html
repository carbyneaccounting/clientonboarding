<!-- masterserviceagreement_page.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Master Service Agreement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<template id="carbyne_masterserviceagreement_page">
  <style>
    .msa-wrap{width:100%}
    .msa-h{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:2px 2px 12px;
    }
    .msa-title{
      margin:0;
      font-size:18px;
      font-weight:950;
      color:#0b2f4e;
      letter-spacing:.2px;
    }
    .msa-sub{
      margin:0;
      font-size:12px;
      font-weight:850;
      color:#334155;
      opacity:.88;
      line-height:1.45;
    }

    .msa-view{
      width:100%;
      border:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 10px 22px rgba(2,6,23,.08);
    }

    .msa-iframe{
      width:100%;
      height:430px;
      border:0;
      display:block;
      background:#fff;
    }

    .msa-actions{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 2px 0;
      flex-wrap:wrap;
    }

    .msa-btn{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      color:#0f172a;
      font-weight:950;
      font-size:12px;
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      transition:transform .12s ease, opacity .12s ease;
      box-shadow:0 8px 18px rgba(2,6,23,.06);
      user-select:none;
      white-space:nowrap;
    }
    .msa-btn.primary{
      background:linear-gradient(90deg, #00305B, #0A3D6F);
      color:#fff;
      border-color:rgba(0,48,91,.25);
    }
    .msa-btn:hover{transform:translateY(-1px);opacity:.97}
    .msa-btn:active{transform:translateY(0);opacity:.96}
    .msa-btn:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .msa-status{
      font-size:12px;
      font-weight:900;
      color:#0f172a;
      opacity:.78;
    }
    .msa-status.bad{color:#b91c1c;opacity:1}
    .msa-status.good{color:#0a7a3a;opacity:1}
  </style>

  <div class="msa-wrap" id="msaRoot">
    <div class="msa-h">
      <h2 class="msa-title">Master Service Agreement</h2>
      <p class="msa-sub">Review the agreement below. When you are ready, select Electronic Sign.</p>
    </div>

    <div class="msa-view">
      <iframe class="msa-iframe" id="msaFrame" title="Master Service Agreement"></iframe>
    </div>

    <div class="msa-actions">
      <div class="msa-status" id="msaStatus">Loading agreement…</div>
      <button class="msa-btn primary" id="msaSignBtn" type="button" disabled>Electronic Sign</button>
    </div>
  </div>
</template>

<script>
(function(){
  const AGREEMENT_TXT_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/refs/heads/main/MasterServiceAgreement.txt";
  const ARIAL_NARROW_TTF_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/main/ARIALN.TTF";

  const FONTKIT_URL = "https://cdn.jsdelivr.net/npm/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js";

  const DOC_ID = "master_service_agreement";
  const DOC_TITLE = "Master Service Agreement";

  function normalize(v){ return (v ?? "").toString(); }

  function bytesToB64(bytes){
    let s = "";
    const chunk = 0x8000;
    for (let i=0;i<bytes.length;i+=chunk){
      s += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
    }
    return btoa(s);
  }

  function stamp(){
    const d = new Date();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
  }

  function setStatus(root, msg, cls){
    const el = root.querySelector("#msaStatus");
    if (!el) return;
    el.classList.remove("bad","good");
    if (cls) el.classList.add(cls);
    el.textContent = msg || "";
  }

  async function fetchText(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  }

  async function fetchBytes(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const ab = await res.arrayBuffer();
    return new Uint8Array(ab);
  }

  function loadScriptOnce(id, src){
    return new Promise((resolve, reject) => {
      const existing = document.getElementById(id);
      if (existing) { resolve(); return; }
      const s = document.createElement("script");
      s.id = id;
      s.src = src;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureFontkit(){
    try{
      if (window.fontkit) return true;
      await loadScriptOnce("carbyne_fontkit_umd", FONTKIT_URL);
      return !!window.fontkit;
    } catch {
      return false;
    }
  }

  function splitParagraphsKeepGrid(text){
    const lines = normalize(text).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const out = [];
    let buf = [];
    function flush(){
      if (!buf.length) return;
      const p = buf.join(" ").replace(/\s+/g," ").trim();
      if (p) out.push(p);
      buf = [];
    }
    for (const rawLine of lines){
      const line = rawLine.replace(/\t/g," ").trim();
      if (!line){ flush(); continue; }
      buf.push(line);
    }
    flush();
    return out;
  }

  function isRomanSection(p){
    return /^([IVXLCDM]+)\.\s+/.test(p);
  }

  function parseRomanSection(p){
    const m = p.match(/^([IVXLCDM]+)\.\s+(.+)$/);
    if (!m) return null;
    return { roman: m[1], title: m[2] };
  }

  function parseLeadLabel(p){
    const m = p.match(/^([A-Za-z][A-Za-z\s\-&]+)\.\s+(.+)$/);
    if (!m) return null;
    const lead = m[1].trim();
    const rest = m[2].trim();
    if (!lead || lead.length > 60) return null;
    if (!rest) return null;
    return { lead, rest };
  }

  function measureText(font, text, size){
    try { return font.widthOfTextAtSize(text, size); } catch { return text.length * (size * 0.5); }
  }

  function wrapWords(font, text, size, maxWidth){
    const words = text.split(/\s+/).filter(Boolean);
    const lines = [];
    let cur = "";
    for (const w of words){
      const test = cur ? (cur + " " + w) : w;
      if (measureText(font, test, size) <= maxWidth){
        cur = test;
      } else {
        if (cur) lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    return lines;
  }

  function drawUnderline(page, x, y, w){
    try{
      page.drawLine({
        start: { x, y: y - 1.2 },
        end: { x: x + w, y: y - 1.2 },
        thickness: 0.7,
        opacity: 1
      });
    } catch {}
  }

  function drawHLine(page, x, y, w){
    try{
      page.drawLine({
        start: { x, y },
        end: { x: x + w, y },
        thickness: 0.9,
        opacity: 1
      });
    } catch {}
  }

  function drawBold(page, font, text, x, y, size){
    page.drawText(text, { x, y, size, font });
    page.drawText(text, { x: x + 0.35, y, size, font });
  }

  function stripEmbeddedUnderscores(text){
    return normalize(text).replace(/_{3,}/g, " ").replace(/\s+/g, " ").trim();
  }

  function looksLikeSignatureBlock(p){
    const s = normalize(p).toLowerCase();
    return (
      s.includes("signature of authorized signatory") ||
      s.includes("printed name and title") ||
      (s.includes("signature") && s.includes("date") && s.includes("_"))
    );
  }

  async function buildAgreementPdfBytes(referenceNumber, agreementText, fontBytes){
    const lib = window.PDFLib;
    if (!lib || !lib.PDFDocument) throw new Error("PDFLib unavailable");

    const { PDFDocument, StandardFonts } = lib;

    const pdfDoc = await PDFDocument.create();

    let bodyFont = null;
    const fontkitReady = await ensureFontkit();

    if (fontkitReady && typeof pdfDoc.registerFontkit === "function") {
      try{
        pdfDoc.registerFontkit(window.fontkit);
        bodyFont = await pdfDoc.embedFont(fontBytes, { subset: true });
      } catch {
        bodyFont = null;
      }
    }

    if (!bodyFont){
      bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    }

    const PAGE_W = 612;
    const PAGE_H = 792;

    const M_LEFT = 54;
    const M_RIGHT = 54;
    const M_TOP = 60;
    const M_BOTTOM = 44;

    const BODY_TOP_Y = PAGE_H - M_TOP - 24;
    const BODY_BOTTOM_Y = M_BOTTOM + 20;

    const FONT_SIZE = 10;
    const LINE_H = 13;
    const MAX_W = PAGE_W - M_LEFT - M_RIGHT;

    const headerLeft = "Carbyne Accounting";
    const headerRight = DOC_TITLE;

    const footerLeft = "Confidential";
    const footerRightPrefix = "Page ";

    const paragraphs = splitParagraphsKeepGrid(agreementText);

    const pages = [];
    function newPage(){
      const p = pdfDoc.addPage([PAGE_W, PAGE_H]);
      pages.push(p);
      return p;
    }

    let page = newPage();
    let y = BODY_TOP_Y;

    function drawHeaderFooter(pageIndex, totalPages){
      const p = pages[pageIndex];
      const headerY = PAGE_H - M_TOP + 10;

      drawBold(p, bodyFont, headerLeft, M_LEFT, headerY, FONT_SIZE);
      const hrw = measureText(bodyFont, headerRight, FONT_SIZE);
      drawBold(p, bodyFont, headerRight, PAGE_W - M_RIGHT - hrw, headerY, FONT_SIZE);

      if (referenceNumber){
        const refText = "Reference: " + referenceNumber;
        const rw = measureText(bodyFont, refText, FONT_SIZE);
        p.drawText(refText, { x: PAGE_W - M_RIGHT - rw, y: headerY - 14, size: FONT_SIZE, font: bodyFont });
      }

      const footerY = M_BOTTOM - 6;

      p.drawText(footerLeft, { x: M_LEFT, y: footerY, size: FONT_SIZE, font: bodyFont });

      const pr = footerRightPrefix + (pageIndex + 1) + " of " + totalPages;
      const prw = measureText(bodyFont, pr, FONT_SIZE);
      p.drawText(pr, { x: PAGE_W - M_RIGHT - prw, y: footerY, size: FONT_SIZE, font: bodyFont });
    }

    function ensureSpace(linesNeeded){
      const need = linesNeeded * LINE_H;
      if (y - need < BODY_BOTTOM_Y){
        page = newPage();
        y = BODY_TOP_Y;
      }
    }

    function drawLine(text, x, isBold){
      if (isBold){
        drawBold(page, bodyFont, text, x, y, FONT_SIZE);
      } else {
        page.drawText(text, { x, y, size: FONT_SIZE, font: bodyFont });
      }
      y -= LINE_H;
    }

    function drawSignatureBlock(){
      const GAP_BEFORE = LINE_H * 3;
      const LINE_Y_OFFSET = 0;

      const lineY = y - GAP_BEFORE;
      const labelY = lineY - (LINE_H * 0.95);
      const nextBlockY = labelY - (LINE_H * 1.35);

      const sigX = M_LEFT;
      const sigW = 360;

      const dateX = sigX + sigW + 56;
      const dateW = PAGE_W - M_RIGHT - dateX;

      const pnX = M_LEFT;
      const pnW = 360;

      // Signature + Date lines
      drawHLine(page, sigX, lineY + LINE_Y_OFFSET, sigW);
      drawHLine(page, dateX, lineY + LINE_Y_OFFSET, dateW);

      // Labels under lines
      page.drawText("Signature of Authorized Signatory", { x: sigX, y: labelY, size: FONT_SIZE, font: bodyFont });
      page.drawText("Date", { x: dateX, y: labelY, size: FONT_SIZE, font: bodyFont });

      // Printed Name line + label
      drawHLine(page, pnX, nextBlockY + (LINE_H * 0.7), pnW);
      page.drawText("Printed Name and Title", { x: pnX, y: nextBlockY - (LINE_H * 0.15), size: FONT_SIZE, font: bodyFont });

      // Advance cursor to below the signature block
      y = nextBlockY - (LINE_H * 1.4);
    }

    for (const rawP of paragraphs){
      if (looksLikeSignatureBlock(rawP)){
        ensureSpace(8);
        drawSignatureBlock();
        continue;
      }

      const p = stripEmbeddedUnderscores(rawP);
      if (!p) continue;

      if (isRomanSection(p)){
        const s = parseRomanSection(p);
        if (!s) continue;

        const roman = s.roman + ".";
        const title = s.title;

        const romanX = M_LEFT;
        const titleX = M_LEFT + 22;

        ensureSpace(1);
        drawBold(page, bodyFont, roman, romanX, y, FONT_SIZE);
        drawBold(page, bodyFont, title, titleX, y, FONT_SIZE);
        y -= LINE_H;

        continue;
      }

      const lead = parseLeadLabel(p);
      if (lead){
        const leadText = lead.lead + ".";
        const restText = lead.rest;

        const leadW = measureText(bodyFont, leadText + " ", FONT_SIZE);
        const maxFirst = Math.max(10, MAX_W - leadW);

        const restLines = wrapWords(bodyFont, restText, FONT_SIZE, maxFirst);
        ensureSpace(Math.max(1, restLines.length));

        // Lead label UNDERLINED (not bold)
        page.drawText(leadText, { x: M_LEFT, y, size: FONT_SIZE, font: bodyFont });
        drawUnderline(page, M_LEFT, y, measureText(bodyFont, leadText, FONT_SIZE));

        const firstRest = restLines[0] || "";
        page.drawText(" " + firstRest, { x: M_LEFT + measureText(bodyFont, leadText, FONT_SIZE), y, size: FONT_SIZE, font: bodyFont });
        y -= LINE_H;

        for (let i=1;i<restLines.length;i++){
          drawLine(restLines[i], M_LEFT, false);
        }

        continue;
      }

      const lines = wrapWords(bodyFont, p, FONT_SIZE, MAX_W);
      ensureSpace(Math.max(1, lines.length));
      for (const ln of lines){
        drawLine(ln, M_LEFT, false);
      }
    }

    const totalPages = pages.length;
    for (let i=0;i<totalPages;i++){
      drawHeaderFooter(i, totalPages);
    }

    const out = await pdfDoc.save();
    return new Uint8Array(out);
  }

  function setIframePdf(frameEl, bytes){
    try{
      const blob = new Blob([bytes], { type:"application/pdf" });
      const url = URL.createObjectURL(blob);
      frameEl.src = url;
      setTimeout(() => { try{ URL.revokeObjectURL(url); } catch{} }, 600000);
    } catch {}
  }

  window.carbyne_masterserviceagreement_page_mount = async function(args){
    const root = args && args.root ? args.root : document;
    const referenceNumber = args && args.referenceNumber ? args.referenceNumber : "";

    const frame = root.querySelector("#msaFrame");
    const signBtn = root.querySelector("#msaSignBtn");

    let done = false;

    function safeDisable(){ try{ if (signBtn) signBtn.disabled = true; } catch {} }
    function safeEnable(){ try{ if (signBtn) signBtn.disabled = false; } catch {} }

    safeDisable();
    setStatus(root, "Loading agreement…");

    try{
      const [txt, fontBytes] = await Promise.all([
        fetchText(AGREEMENT_TXT_URL),
        fetchBytes(ARIAL_NARROW_TTF_URL)
      ]);

      const pdfBytes = await buildAgreementPdfBytes(referenceNumber, txt, fontBytes);

      if (frame) setIframePdf(frame, pdfBytes);

      try{
        const b64 = bytesToB64(pdfBytes);
        window.dispatchEvent(new CustomEvent("carbyne:pdfdoc:upsert", {
          detail: {
            id: DOC_ID,
            title: DOC_TITLE,
            b64: b64,
            meta: {
              referenceNumber: referenceNumber || "",
              createdAt: stamp()
            }
          }
        }));
      } catch {}

      setStatus(root, "Ready", "good");
      safeEnable();

    } catch (e){
      setStatus(root, "Unable to load agreement.", "bad");
      safeDisable();
      console.error("MSA load error:", e);
    }

    function onSign(){
      if (done) return;
      window.dispatchEvent(new CustomEvent("carbyne:agreement:sign", {
        detail: { id: DOC_ID, title: DOC_TITLE, referenceNumber: referenceNumber || "" }
      }));
    }

    try{ if (signBtn) signBtn.addEventListener("click", onSign); } catch {}

    return function unmount(){
      done = true;
      try{ if (signBtn) signBtn.removeEventListener("click", onSign); } catch {}
      try{ if (frame) frame.src = "about:blank"; } catch {}
    };
  };
})();
</script>

</body>
</html>

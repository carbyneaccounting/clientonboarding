<!-- masterserviceagreement_page.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Master Service Agreement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<template id="carbyne_masterserviceagreement_page">
  <style>
    .msa-wrap{width:100%}
    .msa-h{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:2px 2px 12px;
    }
    .msa-title{
      margin:0;
      font-size:18px;
      font-weight:950;
      color:#0b2f4e;
      letter-spacing:.2px;
    }
    .msa-sub{
      margin:0;
      font-size:12px;
      font-weight:850;
      color:#334155;
      opacity:.88;
      line-height:1.45;
    }

    .msa-view{
      width:100%;
      border:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 10px 22px rgba(2,6,23,.08);
    }

    .msa-iframe{
      width:100%;
      height:430px;
      border:0;
      display:block;
      background:#fff;
    }

    .msa-actions{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 2px 0;
      flex-wrap:wrap;
    }

    .msa-btn{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      color:#0f172a;
      font-weight:950;
      font-size:12px;
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      transition:transform .12s ease, opacity .12s ease;
      box-shadow:0 8px 18px rgba(2,6,23,.06);
      user-select:none;
      white-space:nowrap;
    }
    .msa-btn.primary{
      background:linear-gradient(90deg, #00305B, #0A3D6F);
      color:#fff;
      border-color:rgba(0,48,91,.25);
    }
    .msa-btn:hover{transform:translateY(-1px);opacity:.97}
    .msa-btn:active{transform:translateY(0);opacity:.96}
    .msa-btn:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .msa-status{
      font-size:12px;
      font-weight:900;
      color:#0f172a;
      opacity:.78;
    }
    .msa-status.bad{color:#b91c1c;opacity:1}
    .msa-status.good{color:#0a7a3a;opacity:1}
  </style>

  <div class="msa-wrap" id="msaRoot">
    <div class="msa-h">
      <h2 class="msa-title">Master Service Agreement</h2>
      <p class="msa-sub">Review the agreement below. When you are ready, select Electronic Sign.</p>
    </div>

    <div class="msa-view">
      <iframe class="msa-iframe" id="msaFrame" title="Master Service Agreement"></iframe>
    </div>

    <div class="msa-actions">
      <div class="msa-status" id="msaStatus">Loading agreement…</div>
      <button class="msa-btn primary" id="msaSignBtn" type="button" disabled>Electronic Sign</button>
    </div>
  </div>
</template>

<script>
(function(){
  const AGREEMENT_TXT_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/refs/heads/main/MasterServiceAgreement.txt";
  const ARIAL_NARROW_TTF_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/main/ARIALN.TTF";

  const FONTKIT_URL = "https://cdn.jsdelivr.net/npm/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js";

  const DOC_ID = "master_service_agreement";
  const DOC_TITLE = "Master Service Agreement";

  const INTAKE_STORAGE_KEY = "carbyne_intake_business_info";

  function normalize(v){ return (v ?? "").toString(); }

  function bytesToB64(bytes){
    let s = "";
    const chunk = 0x8000;
    for (let i=0;i<bytes.length;i+=chunk){
      s += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
    }
    return btoa(s);
  }

  function stamp(){
    const d = new Date();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
  }

  function setStatus(root, msg, cls){
    const el = root.querySelector("#msaStatus");
    if (!el) return;
    el.classList.remove("bad","good");
    if (cls) el.classList.add(cls);
    el.textContent = msg || "";
  }

  async function fetchText(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  }

  async function fetchBytes(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const ab = await res.arrayBuffer();
    return new Uint8Array(ab);
  }

  function loadScriptOnce(id, src){
    return new Promise((resolve, reject) => {
      const existing = document.getElementById(id);
      if (existing) { resolve(); return; }
      const s = document.createElement("script");
      s.id = id;
      s.src = src;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureFontkit(){
    try{
      if (window.fontkit) return true;
      await loadScriptOnce("carbyne_fontkit_umd", FONTKIT_URL);
      return !!window.fontkit;
    } catch {
      return false;
    }
  }

  function getIntakeData(){
    try{
      const raw = localStorage.getItem(INTAKE_STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  function replaceClientNamePlaceholder(text, businessName){
    if (!businessName) return text;
    
    // Replace the blank line after "Firm to" with the business name in bold markers
    // The pattern is: "Firm to ________________________________________ (hereinafter"
    const pattern = /(Firm to\s+)_{10,}(\s+\(hereinafter "Client"\))/gi;
    const replacement = `$1**${businessName}**$2`;
    
    return text.replace(pattern, replacement);
  }

  function splitParagraphsKeepGrid(text){
    const lines = normalize(text).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const out = [];
    let buf = [];
    function flush(){
      if (!buf.length) return;
      const p = buf.join(" ").replace(/\s+/g," ").trim();
      if (p) out.push(p);
      buf = [];
    }
    for (const rawLine of lines){
      const line = rawLine.replace(/\t/g," ").trim();
      if (!line){ flush(); continue; }
      buf.push(line);
    }
    flush();
    return out;
  }

  function isRomanSection(p){
    return /^([IVXLCDM]+)\.\s+/.test(p);
  }

  function parseRomanSection(p){
    const m = p.match(/^([IVXLCDM]+)\.\s+(.+)$/);
    if (!m) return null;
    return { roman: m[1], title: m[2] };
  }

  function parseLeadLabel(p){
    const m = p.match(/^([A-Za-z][A-Za-z\s\-&]+)\.\s+(.+)$/);
    if (!m) return null;
    const lead = m[1].trim();
    const rest = m[2].trim();
    if (!lead || lead.length > 42) return null;
    if (!rest) return null;
    return { lead, rest };
  }

  function measureText(font, text, size){
    try { return font.widthOfTextAtSize(text, size); } catch { return text.length * (size * 0.5); }
  }

  function wrapWords(font, text, size, maxWidth){
    const words = text.split(/\s+/).filter(Boolean);
    const lines = [];
    let cur = "";
    for (const w of words){
      const test = cur ? (cur + " " + w) : w;
      if (measureText(font, test, size) <= maxWidth){
        cur = test;
      } else {
        if (cur) lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    return lines;
  }

  function drawUnderline(page, x, y, w){
    try{
      page.drawLine({
        start: { x, y: y - 1.2 },
        end: { x: x + w, y: y - 1.2 },
        thickness: 0.7,
        opacity: 1
      });
    } catch {}
  }

  function drawBold(page, font, text, x, y, size){
    page.drawText(text, { x, y, size, font });
    page.drawText(text, { x: x + 0.35, y, size, font });
  }

  function isBasisCheckboxLine(p){
    const t = normalize(p);
    return (
      t.includes("Accrual Basis") &&
      t.includes("Cash Basis") &&
      t.includes("Mixed Method") &&
      t.includes("Other:")
    );
  }

  function isSignatureTrigger(p){
    const t = normalize(p).toLowerCase();
    return t.includes("signature of authorized signatory");
  }

  function parseInlineBold(text){
    // Parse **text** markers for bold
    const parts = [];
    let remaining = text;
    let match;
    const boldRegex = /\*\*([^\*]+)\*\*/g;
    let lastIndex = 0;

    while ((match = boldRegex.exec(text)) !== null) {
      // Add normal text before the bold part
      if (match.index > lastIndex) {
        parts.push({
          text: text.substring(lastIndex, match.index),
          bold: false
        });
      }
      
      // Add bold text
      parts.push({
        text: match[1],
        bold: true
      });
      
      lastIndex = match.index + match[0].length;
    }

    // Add remaining normal text
    if (lastIndex < text.length) {
      parts.push({
        text: text.substring(lastIndex),
        bold: false
      });
    }

    return parts.length > 0 ? parts : [{ text: text, bold: false }];
  }

  async function buildAgreementPdfBytes(referenceNumber, agreementText, fontBytes){
    const lib = window.PDFLib;
    if (!lib || !lib.PDFDocument) throw new Error("PDFLib unavailable");

    const { PDFDocument, StandardFonts, rgb } = lib;

    const pdfDoc = await PDFDocument.create();

    let bodyFont = null;
    const fontkitReady = await ensureFontkit();

    if (fontkitReady && typeof pdfDoc.registerFontkit === "function") {
      try{
        pdfDoc.registerFontkit(window.fontkit);
        bodyFont = await pdfDoc.embedFont(fontBytes, { subset: true });
      } catch {
        bodyFont = null;
      }
    }

    if (!bodyFont){
      bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    }

    const PAGE_W = 612;
    const PAGE_H = 792;

    const M_LEFT = 54;
    const M_RIGHT = 54;
    const M_TOP = 60;
    const M_BOTTOM = 44;

    const BODY_TOP_Y = PAGE_H - M_TOP - 24;
    const BODY_BOTTOM_Y = M_BOTTOM + 20;

    const FONT_SIZE = 10;
    const LINE_H = 13;
    const MAX_W = PAGE_W - M_LEFT - M_RIGHT;

    const headerLeft = "Carbyne Accounting";
    const headerRight = DOC_TITLE;

    const footerCenter = "Confidential";
    const footerRightPrefix = "Page ";

    // Get intake data and replace placeholder
    const intakeData = getIntakeData();
    const businessName = intakeData && intakeData.bi_name ? normalize(intakeData.bi_name).trim() : "";
    const processedText = replaceClientNamePlaceholder(agreementText, businessName);

    const paragraphs = splitParagraphsKeepGrid(processedText);

    const pages = [];
    function newPage(){
      const p = pdfDoc.addPage([PAGE_W, PAGE_H]);
      pages.push(p);
      return p;
    }

    let page = newPage();
    let y = BODY_TOP_Y;

    function drawHeaderFooter(pageIndex, totalPages){
      const p = pages[pageIndex];
      const headerY = PAGE_H - M_TOP + 10;

      drawBold(p, bodyFont, headerLeft, M_LEFT, headerY, FONT_SIZE);
      const hrw = measureText(bodyFont, headerRight, FONT_SIZE);
      drawBold(p, bodyFont, headerRight, PAGE_W - M_RIGHT - hrw, headerY, FONT_SIZE);

      if (referenceNumber){
        const refText = "Reference: " + referenceNumber;
        const rw = measureText(bodyFont, refText, FONT_SIZE);
        p.drawText(refText, { x: PAGE_W - M_RIGHT - rw, y: headerY - 14, size: FONT_SIZE, font: bodyFont });
      }

      const footerY = M_BOTTOM - 6;
      const cw = measureText(bodyFont, footerCenter, FONT_SIZE);
      p.drawText(footerCenter, { x: (PAGE_W - cw) / 2, y: footerY, size: FONT_SIZE, font: bodyFont });

      const pr = footerRightPrefix + (pageIndex + 1) + " of " + totalPages;
      const prw = measureText(bodyFont, pr, FONT_SIZE);
      p.drawText(pr, { x: PAGE_W - M_RIGHT - prw, y: footerY, size: FONT_SIZE, font: bodyFont });
    }

    function ensureSpace(linesNeeded){
      const need = linesNeeded * LINE_H;
      if (y - need < BODY_BOTTOM_Y){
        page = newPage();
        y = BODY_TOP_Y;
      }
    }

    function drawLineText(text, x){
      page.drawText(text, { x, y, size: FONT_SIZE, font: bodyFont });
      y -= LINE_H;
    }

    function drawMixedLine(parts, x){
      // Draw a line with mixed bold/normal text
      let currentX = x;
      
      for (const part of parts) {
        if (part.bold) {
          drawBold(page, bodyFont, part.text, currentX, y, FONT_SIZE);
        } else {
          page.drawText(part.text, { x: currentX, y, size: FONT_SIZE, font: bodyFont });
        }
        currentX += measureText(bodyFont, part.text, FONT_SIZE);
      }
      
      y -= LINE_H;
    }

    function drawCheckboxAtBaseline(x, baselineY, size){
      const ascent = 9;
      const boxTopY = baselineY + ascent;
      page.drawRectangle({
        x: x,
        y: boxTopY - size,
        width: size,
        height: size,
        borderWidth: 1,
        borderColor: rgb(0,0,0)
      });
    }

    function drawBasisCheckboxRow(){
      const box = 10;
      const gapAfterBox = 6;
      const itemGap = 16;

      ensureSpace(2);

      const baselineY = y;
      let x = M_LEFT;

      const items = [
        { label: "Accrual Basis" },
        { label: "Cash Basis" },
        { label: "Mixed Method" },
        { label: "Other:" }
      ];

      for (let i=0;i<items.length;i++){
        drawCheckboxAtBaseline(x, baselineY, box);
        x += box + gapAfterBox;

        if (items[i].label === "Other:") {
          const otherLabel = "Other:";
          page.drawText(otherLabel, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
          x += measureText(bodyFont, otherLabel, FONT_SIZE) + 6;

          const lineW = Math.max(120, (M_LEFT + MAX_W) - x);
          page.drawLine({ start:{x:x,y:baselineY+2}, end:{x:x+lineW,y:baselineY+2}, thickness:0.9 });
          break;
        } else {
          page.drawText(items[i].label, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
          x += measureText(bodyFont, items[i].label, FONT_SIZE) + itemGap;
        }
      }

      y -= LINE_H;
    }

    function drawSignatureBlock(){
      const gapBefore = 5 * LINE_H;
      const gapBetweenRows = 3 * LINE_H;

      ensureSpace(10);

      y -= gapBefore;

      const leftLineX = M_LEFT;
      const rightLineX = M_LEFT + MAX_W * 0.70;

      const leftLineW = (rightLineX - leftLineX) - 22;
      const rightLineW = (M_LEFT + MAX_W) - rightLineX;

      const lineY = y + 6;

      page.drawLine({ start:{x:leftLineX,y:lineY}, end:{x:leftLineX+leftLineW,y:lineY}, thickness:0.9 });
      page.drawLine({ start:{x:rightLineX,y:lineY}, end:{x:rightLineX+rightLineW,y:lineY}, thickness:0.9 });

      const labelY = y - (LINE_H - 2);
      page.drawText("Signature of Authorized Signatory", { x: leftLineX, y: labelY, size: FONT_SIZE, font: bodyFont });
      page.drawText("Date", { x: rightLineX, y: labelY, size: FONT_SIZE, font: bodyFont });

      y -= gapBetweenRows;

      const pnLineY = y + 6;
      page.drawLine({ start:{x:leftLineX,y:pnLineY}, end:{x:leftLineX+leftLineW,y:pnLineY}, thickness:0.9 });
      page.drawText("Printed Name and Title", { x: leftLineX, y: y - (LINE_H - 2), size: FONT_SIZE, font: bodyFont });

      y -= (2 * LINE_H);
    }

    let signatureDrawn = false;

    for (let i=0;i<paragraphs.length;i++){
      const p = paragraphs[i];

      if (isBasisCheckboxLine(p)) {
        drawBasisCheckboxRow();
        continue;
      }

      if (!signatureDrawn && isSignatureTrigger(p)) {
        drawSignatureBlock();
        signatureDrawn = true;

        while (i + 1 < paragraphs.length) {
          const nxt = normalize(paragraphs[i+1]).toLowerCase();
          if (
            nxt === "date" ||
            nxt.includes("printed name and title") ||
            nxt.includes("signature of authorized signatory")
          ) {
            i++;
            continue;
          }
          break;
        }
        continue;
      }

      if (isRomanSection(p)){
        const s = parseRomanSection(p);
        if (!s) continue;

        const roman = s.roman + ".";
        const title = s.title;

        const romanX = M_LEFT;
        const titleX = M_LEFT + 22;

        ensureSpace(1);

        drawBold(page, bodyFont, roman, romanX, y, FONT_SIZE);
        drawBold(page, bodyFont, title, titleX, y, FONT_SIZE);

        y -= LINE_H;
        continue;
      }

      const lead = parseLeadLabel(p);
      if (lead){
        const leadText = lead.lead + ".";
        const restText = lead.rest;

        const leadW = measureText(bodyFont, leadText, FONT_SIZE);
        const maxFirst = Math.max(10, MAX_W - (leadW + 1));

        const restLines = wrapWords(bodyFont, restText, FONT_SIZE, maxFirst);
        ensureSpace(Math.max(1, restLines.length));

        page.drawText(leadText, { x: M_LEFT, y, size: FONT_SIZE, font: bodyFont });
        drawUnderline(page, M_LEFT, y, leadW);

        const firstRest = restLines[0] || "";
        page.drawText(" " + firstRest, {
          x: M_LEFT + leadW,
          y,
          size: FONT_SIZE,
          font: bodyFont
        });
        y -= LINE_H;

        for (let j=1;j<restLines.length;j++){
          drawLineText(restLines[j], M_LEFT);
        }

        continue;
      }

      // Check if paragraph contains bold markers
      if (p.includes("**")) {
        const parts = parseInlineBold(p);
        const lines = [];
        let currentLine = [];
        let currentWidth = 0;

        for (const part of parts) {
          const words = part.text.split(/\s+/).filter(Boolean);
          
          for (const word of words) {
            const wordWidth = measureText(bodyFont, word, FONT_SIZE);
            const spaceWidth = measureText(bodyFont, " ", FONT_SIZE);
            const testWidth = currentWidth + (currentLine.length > 0 ? spaceWidth : 0) + wordWidth;

            if (testWidth <= MAX_W) {
              if (currentLine.length > 0) {
                currentLine.push({ text: " ", bold: false });
                currentWidth += spaceWidth;
              }
              currentLine.push({ text: word, bold: part.bold });
              currentWidth += wordWidth;
            } else {
              if (currentLine.length > 0) {
                lines.push(currentLine);
              }
              currentLine = [{ text: word, bold: part.bold }];
              currentWidth = wordWidth;
            }
          }
        }

        if (currentLine.length > 0) {
          lines.push(currentLine);
        }

        ensureSpace(Math.max(1, lines.length));
        
        for (const line of lines) {
          drawMixedLine(line, M_LEFT);
        }

        continue;
      }

      // Regular paragraph without bold
      const lines = wrapWords(bodyFont, p, FONT_SIZE, MAX_W);
      ensureSpace(Math.max(1, lines.length));
      for (const ln of lines){
        drawLineText(ln, M_LEFT);
      }
    }

    const totalPages = pages.length;
    for (let i=0;i<totalPages;i++){
      drawHeaderFooter(i, totalPages);
    }

    const out = await pdfDoc.save();
    return new Uint8Array(out);
  }

  function setIframePdf(frameEl, bytes){
    try{
      const blob = new Blob([bytes], { type:"application/pdf" });
      const url = URL.createObjectURL(blob);
      frameEl.src = url;
      setTimeout(() => { try{ URL.revokeObjectURL(url); } catch{} }, 600000);
    } catch {}
  }

  window.carbyne_masterserviceagreement_page_mount = async function(args){
    const root = args && args.root ? args.root : document;
    const referenceNumber = args && args.referenceNumber ? args.referenceNumber : "";

    const frame = root.querySelector("#msaFrame");
    const signBtn = root.querySelector("#msaSignBtn");

    let done = false;

    function safeDisable(){ try{ if (signBtn) signBtn.disabled = true; } catch {} }
    function safeEnable(){ try{ if (signBtn) signBtn.disabled = false; } catch {} }

    safeDisable();
    setStatus(root, "Loading agreement…");

    try{
      const [txt, fontBytes] = await Promise.all([
        fetchText(AGREEMENT_TXT_URL),
        fetchBytes(ARIAL_NARROW_TTF_URL)
      ]);

      const pdfBytes = await buildAgreementPdfBytes(referenceNumber, txt, fontBytes);

      if (frame) setIframePdf(frame, pdfBytes);

      try{
        const b64 = bytesToB64(pdfBytes);
        window.dispatchEvent(new CustomEvent("carbyne:pdfdoc:upsert", {
          detail: {
            id: DOC_ID,
            title: DOC_TITLE,
            b64: b64,
            meta: {
              referenceNumber: referenceNumber || "",
              createdAt: stamp()
            }
          }
        }));
      } catch {}

      setStatus(root, "Ready", "good");
      safeEnable();

    } catch (e){
      setStatus(root, "Unable to load agreement.", "bad");
      safeDisable();
      console.error("MSA load error:", e);
    }

    function onSign(){
      if (done) return;
      window.dispatchEvent(new CustomEvent("carbyne:agreement:sign", {
        detail: { id: DOC_ID, title: DOC_TITLE, referenceNumber: referenceNumber || "" }
      }));
    }

    try{ if (signBtn) signBtn.addEventListener("click", onSign); } catch {}

    return function unmount(){
      done = true;
      try{ if (signBtn) signBtn.removeEventListener("click", onSign); } catch {}
      try{ if (frame) frame.src = "about:blank"; } catch {}
    };
  };
})();
</script>

</body>
</html>

<!-- masterserviceagreement_page.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Master Service Agreement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<template id="carbyne_masterserviceagreement_page">
  <style>
    .msa-wrap{width:100%}

    .msa-h{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:2px 2px 12px;
    }

    .msa-headrow{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }

    .msa-left{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
    }

    .msa-title{
      margin:0;
      font-size:18px;
      font-weight:950;
      color:#0b2f4e;
      letter-spacing:.2px;
    }

    .msa-sub{
      margin:0;
      font-size:12px;
      font-weight:850;
      color:#334155;
      opacity:.88;
      line-height:1.45;
    }

    .msa-actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      flex-shrink:0;
    }

    .msa-btn{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      color:#0f172a;
      font-weight:950;
      font-size:12px;
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      transition:transform .12s ease, opacity .12s ease;
      box-shadow:0 8px 18px rgba(2,6,23,.06);
      user-select:none;
      white-space:nowrap;
      pointer-events:auto;
    }
    .msa-btn.primary{
      background:linear-gradient(90deg, #00305B, #0A3D6F);
      color:#fff;
      border-color:rgba(0,48,91,.25);
    }
    .msa-btn:hover{transform:translateY(-1px);opacity:.97}
    .msa-btn:active{transform:translateY(0);opacity:.96}
    .msa-btn:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .msa-status{
      font-size:11px;
      font-weight:900;
      color:#0f172a;
      opacity:.78;
      background:rgba(255,255,255,.95);
      padding:6px 10px;
      border-radius:8px;
      box-shadow:0 4px 12px rgba(2,6,23,.08);
      border:1px solid rgba(0,0,0,.08);
      pointer-events:auto;
      white-space:nowrap;
    }
    .msa-status.bad{color:#b91c1c;opacity:1}
    .msa-status.good{color:#0a7a3a;opacity:1}

    .msa-view{
      width:100%;
      border:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 10px 22px rgba(2,6,23,.08);
      position:relative;
    }

    .msa-iframe{
      width:100%;
      height:430px;
      border:0;
      display:block;
      background:#fff;
    }
  </style>

  <div class="msa-wrap" id="msaRoot">
    <div class="msa-h">
      <div class="msa-headrow">
        <div class="msa-left">
          <h2 class="msa-title">Master Service Agreement</h2>
          <p class="msa-sub">Review the agreement below. When you are ready, select Electronic Sign.</p>
        </div>

        <div class="msa-actions">
          <div class="msa-status" id="msaStatus">Loading agreement‚Ä¶</div>
          <button class="msa-btn primary" id="msaSignBtn" type="button" disabled>Sign Document</button>
        </div>
      </div>
    </div>

    <div class="msa-view">
      <iframe class="msa-iframe" id="msaFrame" title="Master Service Agreement"></iframe>
    </div>
  </div>
</template>

<script>
(function(){
  const AGREEMENT_TXT_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/refs/heads/main/MasterServiceAgreement.txt";
  const ARIAL_NARROW_TTF_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/main/ARIALN.TTF";

  const FONTKIT_URL = "https://cdn.jsdelivr.net/npm/@pdf-lib/fontkit@1.1.1/dist/fontkit.umd.min.js";

  const DOC_ID = "master_service_agreement";
  const DOC_TITLE = "Master Service Agreement";

  const INTAKE_STORAGE_KEY = "carbyne_intake_business_info";

  function normalize(v){ return (v ?? "").toString(); }

  function bytesToB64(bytes){
    let s = "";
    const chunk = 0x8000;
    for (let i=0;i<bytes.length;i+=chunk){
      s += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
    }
    return btoa(s);
  }

  function b64ToBytes(b64){
    const bin = atob(b64);
    const out = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out;
  }

  function bytesToDataUrlPng(bytes){
    const b64 = bytesToB64(bytes);
    return "data:image/png;base64," + b64;
  }

  function stamp(){
    const d = new Date();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
  }

  function setStatus(root, msg, cls){
    const el = root.querySelector("#msaStatus");
    if (!el) return;
    el.classList.remove("bad","good");
    if (cls) el.classList.add(cls);
    el.textContent = msg || "";
  }

  async function fetchText(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  }

  async function fetchBytes(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const ab = await res.arrayBuffer();
    return new Uint8Array(ab);
  }

  function loadScriptOnce(id, src){
    return new Promise((resolve, reject) => {
      const existing = document.getElementById(id);
      if (existing) { resolve(); return; }
      const s = document.createElement("script");
      s.id = id;
      s.src = src;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureFontkit(){
    try{
      if (window.fontkit) return true;
      await loadScriptOnce("carbyne_fontkit_umd", FONTKIT_URL);
      return !!window.fontkit;
    } catch {
      return false;
    }
  }

  function getIntakeData(){
    try{
      const raw = localStorage.getItem(INTAKE_STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  function getColumnValues(){
    try {
      const columnA = localStorage.getItem("carbyne_column_a") || "";
      const columnR = localStorage.getItem("carbyne_column_r") || "";

      function formatCurrency(value) {
        if (!value) return "";
        const cleaned = String(value).replace(/[$,\s]/g, '');
        const num = parseFloat(cleaned);
        if (isNaN(num)) return "";
        return num.toLocaleString('en-US', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        });
      }

      return {
        serviceFees: formatCurrency(columnA),
        retainerAmount: formatCurrency(columnR)
      };
    } catch {
      return { serviceFees: "", retainerAmount: "" };
    }
  }

  function replaceClientNamePlaceholder(text, businessName){
    if (!businessName) return text;
    const pattern = /Firm to\s+_{5,}\s+\(hereinafter/gi;
    const replacement = `Firm to **${businessName}** (hereinafter`;
    return text.replace(pattern, replacement);
  }

  function splitParagraphsKeepGrid(text){
    const lines = normalize(text).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const out = [];
    let buf = [];
    function flush(){
      if (!buf.length) return;
      const p = buf.join(" ").replace(/\s+/g," ").trim();
      if (p) out.push(p);
      buf = [];
    }
    for (const rawLine of lines){
      const line = rawLine.replace(/\t/g," ").trim();
      if (!line){ flush(); continue; }
      buf.push(line);
    }
    flush();
    return out;
  }

  function isRomanSection(p){
    return /^([IVXLCDM]+)\.\s+/.test(p);
  }

  function parseRomanSection(p){
    const m = p.match(/^([IVXLCDM]+)\.\s+(.+)$/);
    if (!m) return null;
    return { roman: m[1], title: m[2] };
  }

  function parseLeadLabel(p){
    const m = p.match(/^([A-Za-z][A-Za-z\s\-&]+)\.\s+(.+)$/);
    if (!m) return null;
    const lead = m[1].trim();
    const rest = m[2].trim();
    if (!lead || lead.length > 42) return null;
    if (!rest) return null;
    return { lead, rest };
  }

  function measureText(font, text, size){
    try { return font.widthOfTextAtSize(text, size); } catch { return text.length * (size * 0.5); }
  }

  function drawUnderline(page, x, y, w){
    try{
      page.drawLine({
        start: { x, y: y - 1.2 },
        end: { x: x + w, y: y - 1.2 },
        thickness: 0.7,
        opacity: 1
      });
    } catch {}
  }

  function drawBold(page, font, text, x, y, size){
    page.drawText(text, { x, y, size, font });
    page.drawText(text, { x: x + 0.35, y, size, font });
  }

  function isBasisCheckboxLine(p){
    const t = normalize(p);
    return (t.includes("Accrual Basis") && t.includes("Cash Basis") && t.includes("Mixed Method") && t.includes("Other:"));
  }

  function isServiceFeesLine(p){
    const t = normalize(p).toLowerCase();
    return t.includes("service fees") && t.includes("total service fees charged per month");
  }

  function isRetainerAmountLine(p){
    const t = normalize(p).toLowerCase();
    return t.includes("retainer fee amount") && t.includes("total retainer amount to be paid");
  }

  function isSignatureTrigger(p){
    const t = normalize(p).toLowerCase();
    return t.includes("signature of authorized signatory");
  }

  function parseInlineBold(text){
    const parts = [];
    const boldRegex = /\*\*(.+?)\*\*/g;
    let lastIndex = 0;
    let match;

    while ((match = boldRegex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        const normalText = text.substring(lastIndex, match.index);
        if (normalText) parts.push({ text: normalText, bold: false });
      }
      parts.push({ text: match[1], bold: true });
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      const remainingText = text.substring(lastIndex);
      if (remainingText) parts.push({ text: remainingText, bold: false });
    }

    return parts.length > 0 ? parts : [{ text: text, bold: false }];
  }

  function tokenizePlain(text){
    return normalize(text).trim().split(/\s+/).filter(Boolean);
  }

  function tokenizeStyled(parts){
    const out = [];
    for (const part of parts){
      const raw = normalize(part.text);
      const words = raw.split(/\s+/).filter(Boolean);
      for (const w of words){
        out.push({ text: w, bold: !!part.bold });
      }
    }
    return out;
  }

  function breakLinesDP(words, widths, spaceW, maxWidth){
    const n = words.length;
    const INF = 1e18;
    const cost = new Array(n + 1).fill(INF);
    const next = new Array(n + 1).fill(-1);
    cost[n] = 0;

    for (let i = n - 1; i >= 0; i--){
      let lineW = 0;
      for (let j = i; j < n; j++){
        if (j === i) lineW = widths[j];
        else lineW += spaceW + widths[j];
        if (lineW > maxWidth) break;

        const slack = maxWidth - lineW;
        const isLast = (j === n - 1);

        let penalty = 0;
        if (!isLast){
          const shortLinePenalty = (slack > maxWidth * 0.35) ? (slack * slack * 6) : 0;
          penalty = (slack * slack) + shortLinePenalty;
        }

        const cand = penalty + cost[j + 1];
        if (cand < cost[i]){
          cost[i] = cand;
          next[i] = j + 1;
        }
      }
    }

    const lines = [];
    let i = 0;
    while (i < n && next[i] !== -1){
      const j = next[i];
      lines.push({ start:i, end:j });
      i = j;
    }
    if (!lines.length && n){
      lines.push({ start:0, end:n });
    }
    return lines;
  }

  async function buildAgreementPdfBytes(referenceNumber, agreementText, fontBytes){
    const lib = window.PDFLib;
    if (!lib || !lib.PDFDocument) throw new Error("PDFLib unavailable");

    const { PDFDocument, StandardFonts, rgb } = lib;

    const pdfDoc = await PDFDocument.create();

    let bodyFont = null;
    const fontkitReady = await ensureFontkit();

    if (fontkitReady && typeof pdfDoc.registerFontkit === "function") {
      try{
        pdfDoc.registerFontkit(window.fontkit);
        bodyFont = await pdfDoc.embedFont(fontBytes, { subset: true });
      } catch {
        bodyFont = null;
      }
    }

    if (!bodyFont){
      bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    }

    const PAGE_W = 612;
    const PAGE_H = 792;

    const M_TOP = 28.8;
    const M_BOTTOM = 28.8;
    const M_LEFT = 36;
    const M_RIGHT = 36;

    const BODY_TOP_Y = PAGE_H - M_TOP - 24;
    const BODY_BOTTOM_Y = M_BOTTOM + 20;

    const FONT_SIZE = 10;
    const LINE_H = 13;
    const MAX_W = PAGE_W - M_LEFT - M_RIGHT;

    const headerLeft = "Carbyne Accounting";
    const headerRight = DOC_TITLE;

    const footerCenter = "Confidential";
    const footerRightPrefix = "Page ";

    const intakeData = getIntakeData();
    const businessName = intakeData && intakeData.bi_name ? normalize(intakeData.bi_name).trim() : "";
    const selectedBasis = intakeData && intakeData.boa_basis ? normalize(intakeData.boa_basis).trim() : "";
    const otherBasisText = intakeData && intakeData.boa_other_text ? normalize(intakeData.boa_other_text).trim() : "";

    const tableData = getColumnValues();
    const serviceFees = tableData.serviceFees;
    const retainerAmount = tableData.retainerAmount;

    const processedText = replaceClientNamePlaceholder(agreementText, businessName);
    const paragraphs = splitParagraphsKeepGrid(processedText);

    const pages = [];
    function newPage(){
      const p = pdfDoc.addPage([PAGE_W, PAGE_H]);
      pages.push(p);
      return p;
    }

    let page = newPage();
    let y = BODY_TOP_Y;

    function drawHeaderFooter(pageIndex, totalPages){
      const p = pages[pageIndex];
      const headerY = PAGE_H - M_TOP + 10;

      drawBold(p, bodyFont, headerLeft, M_LEFT, headerY, FONT_SIZE);
      const hrw = measureText(bodyFont, headerRight, FONT_SIZE);
      drawBold(p, bodyFont, headerRight, PAGE_W - M_RIGHT - hrw, headerY, FONT_SIZE);

      if (referenceNumber){
        const refText = "Reference: " + referenceNumber;
        const rw = measureText(bodyFont, refText, FONT_SIZE);
        p.drawText(refText, { x: PAGE_W - M_RIGHT - rw, y: headerY - 14, size: FONT_SIZE, font: bodyFont });
      }

      const footerY = M_BOTTOM - 6;
      p.drawText(footerCenter, { x: M_LEFT, y: footerY, size: FONT_SIZE, font: bodyFont });

      const pr = footerRightPrefix + (pageIndex + 1) + " of " + totalPages;
      const prw = measureText(bodyFont, pr, FONT_SIZE);
      p.drawText(pr, { x: PAGE_W - M_RIGHT - prw, y: footerY, size: FONT_SIZE, font: bodyFont });
    }

    function ensureSpace(linesNeeded){
      const need = linesNeeded * LINE_H;
      if (y - need < BODY_BOTTOM_Y){
        page = newPage();
        y = BODY_TOP_Y;
      }
    }

    function drawJustifiedPlainLine(words, xStart, width, isLastLine){
      if (!words || !words.length) { y -= LINE_H; return; }
      const spaceW = measureText(bodyFont, " ", FONT_SIZE);

      let wordsW = 0;
      for (const w of words) wordsW += measureText(bodyFont, w, FONT_SIZE);

      const gaps = Math.max(0, words.length - 1);
      const baseW = wordsW + (spaceW * gaps);
      const extra = Math.max(0, width - baseW);
      const perGap = (gaps > 0 && !isLastLine) ? (spaceW + (extra / gaps)) : spaceW;

      let x = xStart;
      for (let i=0;i<words.length;i++){
        const w = words[i];
        page.drawText(w, { x, y, size: FONT_SIZE, font: bodyFont });
        x += measureText(bodyFont, w, FONT_SIZE);
        if (i !== words.length - 1) x += perGap;
      }
      y -= LINE_H;
    }

    function drawJustifiedStyledLine(tokens, xStart, width, isLastLine){
      if (!tokens || !tokens.length) { y -= LINE_H; return; }
      const spaceW = measureText(bodyFont, " ", FONT_SIZE);

      let wordsW = 0;
      for (const t of tokens) wordsW += measureText(bodyFont, t.text, FONT_SIZE);

      const gaps = Math.max(0, tokens.length - 1);
      const baseW = wordsW + (spaceW * gaps);
      const extra = Math.max(0, width - baseW);
      const perGap = (gaps > 0 && !isLastLine) ? (spaceW + (extra / gaps)) : spaceW;

      let x = xStart;
      for (let i=0;i<tokens.length;i++){
        const t = tokens[i];
        if (t.bold) drawBold(page, bodyFont, t.text, x, y, FONT_SIZE);
        else page.drawText(t.text, { x, y, size: FONT_SIZE, font: bodyFont });

        x += measureText(bodyFont, t.text, FONT_SIZE);
        if (i !== tokens.length - 1) x += perGap;
      }
      y -= LINE_H;
    }

    function drawCheckboxAtBaseline(x, baselineY, size){
      const ascent = 9;
      const boxTopY = baselineY + ascent;
      page.drawRectangle({
        x: x,
        y: boxTopY - size,
        width: size,
        height: size,
        borderWidth: 1,
        borderColor: rgb(0,0,0)
      });
    }

    function drawCheckmark(x, baselineY, size){
      const ascent = 9;
      const boxTopY = baselineY + ascent;
      const boxBottomY = boxTopY - size;

      const padding = 2;
      const x1 = x + padding;
      const x2 = x + size - padding;
      const y1 = boxBottomY + padding;
      const y2 = boxTopY - padding;

      page.drawLine({ start: { x: x1, y: y1 }, end: { x: x2, y: y2 }, thickness: 1.2, color: rgb(0,0,0) });
      page.drawLine({ start: { x: x2, y: y1 }, end: { x: x1, y: y2 }, thickness: 1.2, color: rgb(0,0,0) });
    }

    function drawBasisCheckboxRow(){
      const box = 10;
      const gapAfterBox = 6;
      const itemGap = 16;

      ensureSpace(2);

      const baselineY = y;
      let x = M_LEFT;

      const items = [
        { label: "Accrual Basis", value: "Accrual Basis" },
        { label: "Cash Basis", value: "Cash Basis" },
        { label: "Mixed Method", value: "Mixed Method" },
        { label: "Other:", value: "Other" }
      ];

      for (let i=0;i<items.length;i++){
        const item = items[i];

        drawCheckboxAtBaseline(x, baselineY, box);
        const isSelected = (selectedBasis === item.value);
        if (isSelected) drawCheckmark(x, baselineY, box);

        x += box + gapAfterBox;

        if (item.label === "Other:") {
          const otherLabel = "Other:";
          page.drawText(otherLabel, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
          x += measureText(bodyFont, otherLabel, FONT_SIZE) + 6;

          if (isSelected && otherBasisText) {
            page.drawText(otherBasisText, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
            const textWidth = measureText(bodyFont, otherBasisText, FONT_SIZE);
            page.drawLine({ start: {x: x, y: baselineY - 1.2}, end: {x: x + textWidth, y: baselineY - 1.2}, thickness: 0.7 });
          } else {
            const lineW = Math.max(120, (M_LEFT + MAX_W) - x);
            page.drawLine({ start:{x:x,y:baselineY+2}, end:{x:x+lineW,y:baselineY+2}, thickness:0.9 });
          }
          break;
        } else {
          page.drawText(item.label, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
          x += measureText(bodyFont, item.label, FONT_SIZE) + itemGap;
        }
      }

      y -= LINE_H;
    }

    function drawAmountLine(labelText, amount){
      ensureSpace(1);

      const baselineY = y;
      let x = M_LEFT;

      page.drawText(labelText, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
      x += measureText(bodyFont, labelText, FONT_SIZE);

      if (amount) {
        page.drawText(amount, { x, y: baselineY, size: FONT_SIZE, font: bodyFont });
        const amountWidth = measureText(bodyFont, amount, FONT_SIZE);
        page.drawLine({ start: {x: x, y: baselineY - 1.2}, end: {x: x + amountWidth, y: baselineY - 1.2}, thickness: 0.7 });
      } else {
        const lineW = Math.max(100, (M_LEFT + MAX_W) - x - 50);
        page.drawLine({ start:{x:x,y:baselineY+2}, end:{x:x+lineW,y:baselineY+2}, thickness:0.9 });
      }

      y -= LINE_H;
    }

    function drawSignatureBlockAtBottomOfLastPage(){
      const savedPage = page;
      const savedY = y;

      page = pages[pages.length - 1];
      y = M_BOTTOM + 160;

      const gapBetweenRows = 3 * LINE_H;

      const leftLineX = M_LEFT;
      const rightLineX = M_LEFT + MAX_W * 0.70;

      const leftLineW = (rightLineX - leftLineX) - 22;
      const rightLineW = (M_LEFT + MAX_W) - rightLineX;

      const lineY = y + 6;

      page.drawLine({ start:{x:leftLineX,y:lineY}, end:{x:leftLineX+leftLineW,y:lineY}, thickness:0.9 });
      page.drawLine({ start:{x:rightLineX,y:lineY}, end:{x:rightLineX+rightLineW,y:lineY}, thickness:0.9 });

      const labelY = y - (LINE_H - 2);
      page.drawText("Signature of Authorized Signatory", { x: leftLineX, y: labelY, size: FONT_SIZE, font: bodyFont });
      page.drawText("Date", { x: rightLineX, y: labelY, size: FONT_SIZE, font: bodyFont });

      y -= gapBetweenRows;

      const pnLineY = y + 6;
      page.drawLine({ start:{x:leftLineX,y:pnLineY}, end:{x:leftLineX+leftLineW,y:pnLineY}, thickness:0.9 });
      page.drawText("Printed Name and Title", { x: leftLineX, y: y - (LINE_H - 2), size: FONT_SIZE, font: bodyFont });

      y -= (2 * LINE_H);

      page = savedPage;
      y = savedY;
    }

    let signaturePending = false;

    for (let i=0;i<paragraphs.length;i++){
      const p = paragraphs[i];

      if (isBasisCheckboxLine(p)) { drawBasisCheckboxRow(); continue; }

      if (isServiceFeesLine(p)) {
        const labelText = "Service Fees. The total service fees charged per month by Firm to Client shall be: $";
        drawAmountLine(labelText, serviceFees);
        continue;
      }

      if (isRetainerAmountLine(p)) {
        const labelText = "Retainer Fee Amount. The total retainer amount to be paid by Client shall be: $";
        drawAmountLine(labelText, retainerAmount);
        continue;
      }

      if (!signaturePending && isSignatureTrigger(p)) {
        signaturePending = true;

        while (i + 1 < paragraphs.length) {
          const nxt = normalize(paragraphs[i+1]).toLowerCase();
          if (nxt === "date" || nxt.includes("printed name and title") || nxt.includes("signature of authorized signatory")) {
            i++;
            continue;
          }
          break;
        }
        continue;
      }

      if (isRomanSection(p)){
        const s = parseRomanSection(p);
        if (!s) continue;

        const roman = s.roman + ".";
        const title = s.title;

        const romanX = M_LEFT;
        const titleX = M_LEFT + 22;

        ensureSpace(2);

        drawBold(page, bodyFont, roman, romanX, y, FONT_SIZE);
        drawBold(page, bodyFont, title, titleX, y, FONT_SIZE);
        y -= LINE_H;
        continue;
      }

      const lead = parseLeadLabel(p);
      if (lead){
        const leadText = lead.lead + ".";
        const restText = lead.rest;

        const leadW = measureText(bodyFont, leadText, FONT_SIZE);
        const spaceW = measureText(bodyFont, " ", FONT_SIZE);

        const firstX = M_LEFT + leadW + spaceW;
        const firstW = Math.max(20, (M_LEFT + MAX_W) - firstX);

        const restWords = tokenizePlain(restText);
        const widths = restWords.map(w => measureText(bodyFont, w, FONT_SIZE));

        let bestK = 0;
        let bestScore = 1e18;

        let wAcc = 0;
        for (let k = 0; k < restWords.length; k++){
          if (k === 0) wAcc = widths[0];
          else wAcc += spaceW + widths[k];
          if (wAcc > firstW) break;

          const slack = firstW - wAcc;

          const remWords = restWords.slice(k+1);
          let remCost = 0;
          if (remWords.length){
            const remWidths = remWords.map(w => measureText(bodyFont, w, FONT_SIZE));
            const remLines = breakLinesDP(remWords, remWidths, spaceW, MAX_W);
            remCost = 0;
            for (let li=0; li<remLines.length; li++){
              const seg = remLines[li];
              let lw = 0;
              for (let t=seg.start; t<seg.end; t++){
                if (t === seg.start) lw = remWidths[t];
                else lw += spaceW + remWidths[t];
              }
              const isLast = (li === remLines.length - 1);
              if (!isLast){
                const s2 = (MAX_W - lw);
                remCost += (s2*s2);
              }
            }
          }

          const total = (slack*slack) + remCost;
          if (total < bestScore){
            bestScore = total;
            bestK = k;
          }
        }

        ensureSpace(1);

        page.drawText(leadText, { x: M_LEFT, y, size: FONT_SIZE, font: bodyFont });
        drawUnderline(page, M_LEFT, y, leadW);

        if (restWords.length){
          const firstWords = restWords.slice(0, bestK+1);
          drawJustifiedPlainLine(firstWords, firstX, firstW, true);
        } else {
          y -= LINE_H;
        }

        const remWords = restWords.slice(bestK+1);
        if (remWords.length){
          const remWidths = remWords.map(w => measureText(bodyFont, w, FONT_SIZE));
          const lines = breakLinesDP(remWords, remWidths, spaceW, MAX_W);

          ensureSpace(lines.length);

          for (let li=0; li<lines.length; li++){
            const seg = lines[li];
            const isLast = (li === lines.length - 1);
            const lineWords = remWords.slice(seg.start, seg.end);
            drawJustifiedPlainLine(lineWords, M_LEFT, MAX_W, isLast);
          }
        }
        continue;
      }

      if (p.includes("**")) {
        const parts = parseInlineBold(p);
        const tokens = tokenizeStyled(parts);

        const spaceW = measureText(bodyFont, " ", FONT_SIZE);
        const widths2 = tokens.map(t => measureText(bodyFont, t.text, FONT_SIZE));
        const words2 = tokens.map(t => t.text);

        const lines2 = breakLinesDP(words2, widths2, spaceW, MAX_W);

        ensureSpace(Math.max(1, lines2.length));

        for (let li=0; li<lines2.length; li++){
          const seg = lines2[li];
          const isLast = (li === lines2.length - 1);
          const lineTokens = tokens.slice(seg.start, seg.end);
          drawJustifiedStyledLine(lineTokens, M_LEFT, MAX_W, isLast);
        }
        continue;
      }

      const words = tokenizePlain(p);
      if (!words.length) continue;

      const spaceW = measureText(bodyFont, " ", FONT_SIZE);
      const widths3 = words.map(w => measureText(bodyFont, w, FONT_SIZE));
      const lines3 = breakLinesDP(words, widths3, spaceW, MAX_W);

      ensureSpace(Math.max(1, lines3.length));

      for (let li=0; li<lines3.length; li++){
        const seg = lines3[li];
        const isLast = (li === lines3.length - 1);
        const lineWords = words.slice(seg.start, seg.end);
        drawJustifiedPlainLine(lineWords, M_LEFT, MAX_W, isLast);
      }
    }

    if (signaturePending){
      drawSignatureBlockAtBottomOfLastPage();
    }

    const totalPages = pages.length;
    for (let i=0;i<totalPages;i++){
      drawHeaderFooter(i, totalPages);
    }

    const out = await pdfDoc.save();
    return new Uint8Array(out);
  }

  function setIframePdf(frameEl, bytes){
    try{
      const blob = new Blob([bytes], { type:"application/pdf" });
      const url = URL.createObjectURL(blob);
      frameEl.src = url;
      setTimeout(() => { try{ URL.revokeObjectURL(url); } catch{} }, 600000);
    } catch {}
  }

  function getStoredValue(key){
    try{
      const v1 = localStorage.getItem(key);
      if (v1) return v1;
    } catch {}
    try{
      const v2 = sessionStorage.getItem(key);
      if (v2) return v2;
    } catch {}
    return "";
  }

  function getAdoptedTypedSignatureText(){
    const keys = [
      "carbyne_adopted_signature_text",
      "carbyne_adopted_signature_typed",
      "carbyne_adopted_signature_typed_text",
      "carbyne_typed_signature",
      "carbyne_typed_signature_text",
      "carbyne_signature_text",
      "carbyne_signature_typed",
      "carbyne_signature_typed_text",
      "adopted_signature_text",
      "adopted_signature_typed",
      "adopted_signature_typed_text",
      "typed_signature",
      "typed_signature_text",
      "signature_text",
      "signature_typed",
      "signature_typed_text"
    ];

    const globals = [
      window.__carbyne_adopted_signature_text,
      window.carbyne_adopted_signature_text,
      window.carbyneAdoptedSignatureText,
      window.adoptedSignatureText
    ].filter(Boolean).map(v => normalize(v));

    for (const g of globals){
      const s = normalize(g).trim();
      if (s) return s;
    }

    for (const k of keys){
      const v = getStoredValue(k);
      const s = normalize(v).trim();
      if (s) return s;
    }

    return "";
  }

  function getAdoptedSignatureImageValue(){
    const keys = [
      "carbyne_adopted_signature",
      "carbyne_adopted_signature_png",
      "carbyne_adopted_signature_b64",
      "carbyne_adopted_signature_dataurl",
      "carbyne_adopted_signature_data_url",
      "carbyne_signature",
      "carbyne_signature_png",
      "carbyne_signature_b64",
      "carbyne_signature_dataurl",
      "carbyne_signature_data_url",
      "adopted_signature",
      "adopted_signature_png",
      "adopted_signature_b64",
      "adopted_signature_dataurl",
      "adopted_signature_data_url"
    ];

    const globals = [
      window.__carbyne_adopted_signature_dataurl,
      window.carbyne_adopted_signature_dataurl,
      window.carbyneAdoptedSignatureDataUrl,
      window.carbyneAdoptedSignature,
      window.adoptedSignatureDataUrl,
      window.adoptedSignature
    ].filter(Boolean).map(v => normalize(v));

    for (const g of globals){
      const s = normalize(g).trim();
      if (s) return s;
    }

    for (const k of keys){
      const v = getStoredValue(k);
      const s = normalize(v).trim();
      if (s) return s;
    }

    return "";
  }

  function getAdoptedSignature(){
    // PRIORITY: First check for typed signature text
    const typedText = getAdoptedTypedSignatureText();
    if (typedText) {
      console.log("‚úÖ Found typed signature:", typedText);
      return { kind:"text", text: typedText };
    }

    // Fall back to image signature
    const raw = normalize(getAdoptedSignatureImageValue()).trim();
    if (!raw) return null;

    if (/^data:image\/png;base64,/i.test(raw)){
      const b64 = raw.split(",")[1] || "";
      if (!b64) return null;
      return { kind:"png", bytes: b64ToBytes(b64) };
    }

    if (/^data:image\/jpeg;base64,/i.test(raw) || /^data:image\/jpg;base64,/i.test(raw)){
      const b64 = raw.split(",")[1] || "";
      if (!b64) return null;
      return { kind:"jpg", bytes: b64ToBytes(b64) };
    }

    if (/^[A-Za-z0-9+/=]+$/.test(raw) && raw.length > 200){
      try { return { kind:"png", bytes: b64ToBytes(raw) }; } catch {}
    }

    return null;
  }

  async function cropPngToInk(pngBytes){
    const dataUrl = bytesToDataUrlPng(pngBytes);

    const img = new Image();
    img.decoding = "async";

    const loaded = await new Promise((resolve, reject) => {
      img.onload = () => resolve(true);
      img.onerror = () => reject(new Error("Image load failed"));
      img.src = dataUrl;
    });

    if (!loaded) return pngBytes;

    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;
    if (!w || !h) return pngBytes;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) return pngBytes;

    ctx.clearRect(0,0,w,h);
    ctx.drawImage(img, 0, 0);

    const imgData = ctx.getImageData(0, 0, w, h);
    const data = imgData.data;

    let minX = w, minY = h, maxX = -1, maxY = -1;

    for (let y = 0; y < h; y++){
      for (let x = 0; x < w; x++){
        const idx = (y * w + x) * 4;
        const a = data[idx + 3];
        if (a > 10){
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (maxX < 0 || maxY < 0) return pngBytes;

    const pad = 3;
    minX = Math.max(0, minX - pad);
    minY = Math.max(0, minY - pad);
    maxX = Math.min(w - 1, maxX + pad);
    maxY = Math.min(h - 1, maxY + pad);

    const cw = Math.max(1, (maxX - minX + 1));
    const ch = Math.max(1, (maxY - minY + 1));

    const cropCanvas = document.createElement("canvas");
    cropCanvas.width = cw;
    cropCanvas.height = ch;
    const cctx = cropCanvas.getContext("2d");
    if (!cctx) return pngBytes;

    cctx.clearRect(0,0,cw,ch);
    cctx.drawImage(canvas, minX, minY, cw, ch, 0, 0, cw, ch);

    const outUrl = cropCanvas.toDataURL("image/png");
    const outB64 = outUrl.split(",")[1] || "";
    if (!outB64) return pngBytes;

    try { return b64ToBytes(outB64); } catch { return pngBytes; }
  }

  async function signPdfBytes(pdfBytes, fontBytes, intakeData){
    const lib = window.PDFLib;
    if (!lib || !lib.PDFDocument) throw new Error("PDFLib unavailable");
    const { PDFDocument, StandardFonts, rgb } = lib;

    const sig = getAdoptedSignature();
    if (!sig) throw new Error("No adopted signature available");

    console.log("üìù Signature type:", sig.kind);

    const pdfDoc = await PDFDocument.load(pdfBytes);

    // CRITICAL: Embed the Arial Narrow font for the signature
    let bodyFont = null;
    const fontkitReady = await ensureFontkit();
    
    if (fontkitReady && typeof pdfDoc.registerFontkit === "function") {
      try{
        pdfDoc.registerFontkit(window.fontkit);
        bodyFont = await pdfDoc.embedFont(fontBytes, { subset: true });
        console.log("‚úÖ Arial Narrow font embedded for signature");
      } catch (e) {
        console.error("‚ùå Failed to embed Arial Narrow for signature:", e);
        bodyFont = null;
      }
    }
    
    if (!bodyFont){
      bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
      console.log("‚ö†Ô∏è Using Helvetica fallback for signature");
    }

    const pages = pdfDoc.getPages();
    const lastPage = pages[pages.length - 1];

    const PAGE_W = 612;
    const M_LEFT = 36;
    const M_RIGHT = 36;
    const M_BOTTOM = 28.8;
    const MAX_W = PAGE_W - M_LEFT - M_RIGHT;
    const LINE_H = 13;

    const signatureBlockY = M_BOTTOM + 160;
    const leftLineX = M_LEFT;
    const rightLineX = M_LEFT + MAX_W * 0.70;
    const leftLineW = (rightLineX - leftLineX) - 22;
    const lineY = signatureBlockY + 6;

    // Draw the signature (typed or image)
    if (sig.kind === "text"){
      const fontSize = 10;  // Arial Narrow 10pt for typed signatures
      const maxTextW = Math.max(40, leftLineW - 2);

      let text = normalize(sig.text).replace(/\s+/g, " ").trim();
      if (!text) throw new Error("No typed signature text available");

      // Prepend /s/ if not already present
      if (!text.startsWith("/s/")) {
        text = "/s/ " + text;
      }

      console.log("üìù Drawing typed signature:", text, "at Arial Narrow", fontSize + "pt");

      // Truncate if needed
      while (text.length > 0 && measureText(bodyFont, text, fontSize) > maxTextW){
        text = text.slice(0, -1);
      }

      if (!text) throw new Error("Typed signature did not fit");

      // Draw typed signature at Arial Narrow 10pt, left-aligned ABOVE the signature line
      lastPage.drawText(text, {
        x: leftLineX,
        y: lineY + 2,  // Position ABOVE the line
        size: fontSize,
        font: bodyFont,
        color: rgb(0, 0, 0)
      });

      console.log("‚úÖ Typed signature drawn at x:", leftLineX, "y:", lineY + 2, "size:", fontSize);

    } else {
      // Draw image signature
      let embeddedImg = null;

      if (sig.kind === "png"){
        const cropped = await cropPngToInk(sig.bytes);
        embeddedImg = await pdfDoc.embedPng(cropped);
      } else {
        embeddedImg = await pdfDoc.embedJpg(sig.bytes);
      }

      const imgNaturalW = embeddedImg.width;
      const imgNaturalH = embeddedImg.height;

      const maxW = Math.max(60, leftLineW);
      const maxH = 26;

      const scaleW = maxW / imgNaturalW;
      const scaleH = maxH / imgNaturalH;
      const scale = Math.min(scaleW, scaleH, 1);

      const drawW = imgNaturalW * scale;
      const drawH = imgNaturalH * scale;

      const imgX = leftLineX;
      const imgY = lineY + 2;  // Position image ABOVE the line

      lastPage.drawImage(embeddedImg, {
        x: imgX,
        y: imgY,
        width: drawW,
        height: drawH
      });

      console.log("‚úÖ Image signature drawn at x:", imgX, "y:", imgY);
    }

    // Add today's date above the Date line
    const today = new Date();
    const month = String(today.getMonth() + 1).padStart(2, "0");
    const day = String(today.getDate()).padStart(2, "0");
    const year = today.getFullYear();
    const dateText = `${month}-${day}-${year}`;

    const dateFontSize = 10;  // Arial Narrow 10pt for date

    // Draw date ABOVE the Date line, left-aligned at rightLineX
    lastPage.drawText(dateText, {
      x: rightLineX,
      y: lineY + 2,  // Same Y position as signature (above the line)
      size: dateFontSize,
      font: bodyFont,
      color: rgb(0, 0, 0)
    });

    console.log("‚úÖ Date drawn:", dateText, "at x:", rightLineX, "y:", lineY + 2, "size:", dateFontSize);

    // NEW: Add printed name and title above the Printed Name and Title line
    const gapBetweenRows = 3 * LINE_H;
    const printedNameLineY = lineY - gapBetweenRows;

    console.log("üîç Debugging printed name:");
    console.log("  intakeData:", intakeData);

    let printedNameAndTitle = "";

    if (intakeData) {
      // FIXED: Use bi_fullname instead of bi_first_name and bi_last_name
      const fullName = normalize(intakeData.bi_fullname || "").trim();
      const title = normalize(intakeData.bi_title || "").trim();

      console.log("  fullName:", fullName);
      console.log("  title:", title);
      
      if (fullName && title) {
        printedNameAndTitle = `${fullName}, ${title}`;
      } else if (fullName) {
        printedNameAndTitle = fullName;
      }
      
      console.log("  printedNameAndTitle:", printedNameAndTitle);
    } else {
      console.log("  ‚ùå No intakeData available");
    }

    if (printedNameAndTitle) {
      const printedFontSize = 10; // Arial Narrow 10pt

      console.log("  üìù Drawing printed name and title:", printedNameAndTitle);
      console.log("  Position: x =", leftLineX, "y =", printedNameLineY + 2);

      // Draw printed name and title ABOVE the Printed Name and Title line
      lastPage.drawText(printedNameAndTitle, {
        x: leftLineX,
        y: printedNameLineY + 2, // Same offset as signature (above the line)
        size: printedFontSize,
        font: bodyFont,
        color: rgb(0, 0, 0)
      });

      console.log("‚úÖ Printed name and title drawn successfully");
    } else {
      console.log("‚ùå printedNameAndTitle is empty, not drawing");
    }

    const out = await pdfDoc.save();
    return new Uint8Array(out);
  }

  window.carbyne_masterserviceagreement_page_mount = async function(args){
    const root = args && args.root ? args.root : document;
    const referenceNumber = args && args.referenceNumber ? args.referenceNumber : "";

    const frame = root.querySelector("#msaFrame");
    const signBtn = root.querySelector("#msaSignBtn");

    let done = false;

    let latestPdfBytes = null;
    let latestFontBytes = null;

    function safeDisable(){ try{ if (signBtn) signBtn.disabled = true; } catch {} }
    function safeEnable(){ try{ if (signBtn) signBtn.disabled = false; } catch {} }

    safeDisable();
    setStatus(root, "Loading agreement‚Ä¶");

    try{
      const [txt, fontBytes] = await Promise.all([
        fetchText(AGREEMENT_TXT_URL),
        fetchBytes(ARIAL_NARROW_TTF_URL)
      ]);

      latestFontBytes = fontBytes;

      const pdfBytes = await buildAgreementPdfBytes(referenceNumber, txt, fontBytes);
      latestPdfBytes = pdfBytes;

      if (frame) setIframePdf(frame, pdfBytes);

      try{
        const b64 = bytesToB64(pdfBytes);
        window.dispatchEvent(new CustomEvent("carbyne:pdfdoc:upsert", {
          detail: {
            id: DOC_ID,
            title: DOC_TITLE,
            b64: b64,
            meta: {
              referenceNumber: referenceNumber || "",
              createdAt: stamp()
            }
          }
        }));
      } catch {}

      setStatus(root, "Ready", "good");
      safeEnable();

    } catch (e){
      setStatus(root, "Unable to load agreement.", "bad");
      safeDisable();
      console.error("MSA load error:", e);
    }

    async function onSign(){
      if (done) return;
      if (!latestPdfBytes || !latestFontBytes) return;

      safeDisable();
      setStatus(root, "Signing‚Ä¶");

      try{
        const intakeData = getIntakeData(); // Get intake data here
        const signedBytes = await signPdfBytes(latestPdfBytes, latestFontBytes, intakeData); // Pass it to signPdfBytes
        latestPdfBytes = signedBytes;

        if (frame) setIframePdf(frame, signedBytes);

        try{
          const b64 = bytesToB64(signedBytes);
          window.dispatchEvent(new CustomEvent("carbyne:pdfdoc:upsert", {
            detail: {
              id: DOC_ID,
              title: DOC_TITLE,
              b64: b64,
              meta: {
                referenceNumber: referenceNumber || "",
                createdAt: stamp(),
                signedAt: stamp()
              }
            }
          }));
        } catch {}

        setStatus(root, "Signed", "good");
        safeEnable();
      } catch (e){
        setStatus(root, "Unable to sign document.", "bad");
        console.error("MSA sign error:", e);
        safeEnable();
      }
    }

    try{ if (signBtn) signBtn.addEventListener("click", onSign); } catch {}

    return function unmount(){
      done = true;
      try{ if (signBtn) signBtn.removeEventListener("click", onSign); } catch {}
      try{ if (frame) frame.src = "about:blank"; } catch {}
    };
  };
})();
</script>

</body>
</html>

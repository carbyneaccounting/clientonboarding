<!-- masterserviceagreement_page.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Master Service Agreement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<template id="carbyne_masterserviceagreement_page">
  <style>
    .msa-wrap{width:100%}
    .msa-h{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:2px 2px 12px;
    }
    .msa-title{
      margin:0;
      font-size:18px;
      font-weight:950;
      color:#0b2f4e;
      letter-spacing:.2px;
    }
    .msa-sub{
      margin:0;
      font-size:12px;
      font-weight:850;
      color:#334155;
      opacity:.88;
      line-height:1.45;
    }

    .msa-view{
      width:100%;
      border:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 10px 22px rgba(2,6,23,.08);
    }

    .msa-iframe{
      width:100%;
      height:430px;
      border:0;
      display:block;
      background:#fff;
    }

    .msa-actions{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 2px 0;
      flex-wrap:wrap;
    }

    .msa-btn{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      color:#0f172a;
      font-weight:950;
      font-size:12px;
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      transition:transform .12s ease, opacity .12s ease;
      box-shadow:0 8px 18px rgba(2,6,23,.06);
      user-select:none;
      white-space:nowrap;
    }
    .msa-btn.primary{
      background:linear-gradient(90deg, #00305B, #0A3D6F);
      color:#fff;
      border-color:rgba(0,48,91,.25);
    }
    .msa-btn:hover{transform:translateY(-1px);opacity:.97}
    .msa-btn:active{transform:translateY(0);opacity:.96}
    .msa-btn:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .msa-status{
      font-size:12px;
      font-weight:900;
      color:#0f172a;
      opacity:.78;
    }
    .msa-status.bad{color:#b91c1c;opacity:1}
    .msa-status.good{color:#0a7a3a;opacity:1}
  </style>

  <div class="msa-wrap" id="msaRoot">
    <div class="msa-h">
      <h2 class="msa-title">Master Service Agreement</h2>
      <p class="msa-sub">Review the agreement below. When you are ready, select Electronic Sign.</p>
    </div>

    <div class="msa-view">
      <iframe class="msa-iframe" id="msaFrame" title="Master Service Agreement"></iframe>
    </div>

    <div class="msa-actions">
      <div class="msa-status" id="msaStatus">Loading agreement…</div>
      <button class="msa-btn primary" id="msaSignBtn" type="button" disabled>Electronic Sign</button>
    </div>
  </div>
</template>

<script>
(function(){
  // FIXED: correct raw GitHub URLs (no /refs/heads/)
  const AGREEMENT_TXT_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/main/MasterServiceAgreement.txt";
  const ARIAL_NARROW_TTF_URL = "https://raw.githubusercontent.com/carbyneaccounting/clientonboarding/main/ARIALN.TTF";

  const DOC_ID = "master_service_agreement";
  const DOC_TITLE = "Master Service Agreement";

  function normalize(v){ return (v ?? "").toString(); }
  function trim(v){ return normalize(v).trim(); }

  function bytesToB64(bytes){
    let s = "";
    const chunk = 0x8000;
    for (let i=0;i<bytes.length;i+=chunk){
      s += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
    }
    return btoa(s);
  }

  function stamp(){
    const d = new Date();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
  }

  function setStatus(root, msg, cls){
    const el = root.querySelector("#msaStatus");
    if (!el) return;
    el.classList.remove("bad","good");
    if (cls) el.classList.add(cls);
    el.textContent = msg || "";
  }

  async function fetchText(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  }

  async function fetchBytes(url){
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const ab = await res.arrayBuffer();
    return new Uint8Array(ab);
  }

  function splitParagraphsKeepGrid(text){
    const lines = normalize(text).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    const out = [];
    let buf = [];

    function flush(){
      if (!buf.length) return;
      const p = buf.join(" ").replace(/\s+/g," ").trim();
      if (p) out.push(p);
      buf = [];
    }

    for (const rawLine of lines){
      const line = rawLine.replace(/\t/g," ").trim();
      if (!line){
        flush();
        continue;
      }
      buf.push(line);
    }
    flush();
    return out;
  }

  function isRomanSection(p){
    return /^([IVXLCDM]+)\.\s+/.test(p);
  }

  function parseRomanSection(p){
    const m = p.match(/^([IVXLCDM]+)\.\s+(.+)$/);
    if (!m) return null;
    return { roman: m[1], title: m[2] };
  }

  function parseBoldLeadLabel(p){
    const m = p.match(/^([A-Za-z][A-Za-z\s\-&]+)\.\s+(.+)$/);
    if (!m) return null;
    const lead = m[1].trim();
    const rest = m[2].trim();
    if (!lead || lead.length > 42) return null;
    if (!rest) return null;
    return { lead, rest };
  }

  function measureText(font, text, size){
    try { return font.widthOfTextAtSize(text, size); } catch { return text.length * (size * 0.5); }
  }

  function wrapWords(font, text, size, maxWidth){
    const words = text.split(/\s+/).filter(Boolean);
    const lines = [];
    let cur = "";

    for (const w of words){
      const test = cur ? (cur + " " + w) : w;
      if (measureText(font, test, size) <= maxWidth){
        cur = test;
      } else {
        if (cur) lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    return lines;
  }

  function drawUnderline(page, x, y, w){
    try{
      page.drawLine({
        start: { x, y: y - 1.15 },
        end: { x: x + w, y: y - 1.15 },
        thickness: 0.7,
        opacity: 1
      });
    } catch {}
  }

  function drawBold(page, font, text, x, y, size){
    page.drawText(text, { x, y, size, font });
    page.drawText(text, { x: x + 0.35, y, size, font });
  }

  async function buildAgreementPdfBytes(referenceNumber, agreementText, fontBytes){
    const lib = window.PDFLib;
    if (!lib || !lib.PDFDocument) throw new Error("PDFLib unavailable");

    const { PDFDocument } = lib;

    const pdfDoc = await PDFDocument.create();
    const arialNarrow = await pdfDoc.embedFont(fontBytes, { subset: true });

    const PAGE_W = 612;
    const PAGE_H = 792;

    const M_LEFT = 54;
    const M_RIGHT = 54;
    const M_TOP = 56;
    const M_BOTTOM = 46;

    const FONT_SIZE = 10;
    const LINE_H = 12;
    const MAX_W = PAGE_W - M_LEFT - M_RIGHT;

    const headerLeft = "Carbyne Accounting";
    const headerRight = referenceNumber ? ("Reference: " + referenceNumber) : "Reference:";

    const footerCenter = "Confidential & Proprietary";
    const footerRightPrefix = "Page ";

    const rawParagraphs = splitParagraphsKeepGrid(agreementText);

    let paragraphs = rawParagraphs.slice();
    if (paragraphs.length){
      const first = trim(paragraphs[0]).toLowerCase();
      if (first === DOC_TITLE.toLowerCase()) paragraphs = paragraphs.slice(1);
    }

    const pages = [];
    function newPage(){
      const p = pdfDoc.addPage([PAGE_W, PAGE_H]);
      pages.push(p);
      return p;
    }

    function drawHeaderFooter(pageIndex, totalPages){
      const p = pages[pageIndex];

      const headerY = PAGE_H - M_TOP + 10;
      drawBold(p, arialNarrow, headerLeft, M_LEFT, headerY, FONT_SIZE);

      const hrw = measureText(arialNarrow, headerRight, FONT_SIZE);
      drawBold(p, arialNarrow, headerRight, PAGE_W - M_RIGHT - hrw, headerY, FONT_SIZE);

      const footerY = M_BOTTOM - 6;
      const cw = measureText(arialNarrow, footerCenter, FONT_SIZE);
      p.drawText(footerCenter, { x: (PAGE_W - cw) / 2, y: footerY, size: FONT_SIZE, font: arialNarrow });

      const pr = footerRightPrefix + (pageIndex + 1);
      const prw = measureText(arialNarrow, pr, FONT_SIZE);
      p.drawText(pr, { x: PAGE_W - M_RIGHT - prw, y: footerY, size: FONT_SIZE, font: arialNarrow });
    }

    const BODY_TOP_Y = PAGE_H - M_TOP - 36;
    const BODY_BOTTOM_Y = M_BOTTOM + 18;

    let page = newPage();
    let y = BODY_TOP_Y;

    function ensureSpace(linesNeeded){
      const need = linesNeeded * LINE_H;
      if (y - need < BODY_BOTTOM_Y){
        page = newPage();
        y = BODY_TOP_Y;
      }
    }

    function drawLine(text, x, isBold){
      if (isBold){
        drawBold(page, arialNarrow, text, x, y, FONT_SIZE);
      } else {
        page.drawText(text, { x, y, size: FONT_SIZE, font: arialNarrow });
      }
      y -= LINE_H;
    }

    function blankLine(){
      y -= LINE_H;
    }

    ensureSpace(2);
    drawBold(page, arialNarrow, DOC_TITLE, M_LEFT, y, FONT_SIZE + 2);
    y -= (LINE_H + 2);
    blankLine();

    for (let pi = 0; pi < paragraphs.length; pi++){
      const ptxt = paragraphs[pi];

      if (isRomanSection(ptxt)){
        const s = parseRomanSection(ptxt);
        if (!s) continue;

        const roman = s.roman + ".";
        const title = s.title;

        const romanX = M_LEFT;
        const titleX = M_LEFT + 22;

        const titleW = Math.min(measureText(arialNarrow, title, FONT_SIZE), MAX_W - 22);

        ensureSpace(2);
        drawBold(page, arialNarrow, roman, romanX, y, FONT_SIZE);
        drawBold(page, arialNarrow, title, titleX, y, FONT_SIZE);
        drawUnderline(page, titleX, y, titleW);
        y -= LINE_H;
        blankLine();
        continue;
      }

      const lead = parseBoldLeadLabel(ptxt);
      if (lead){
        const leadText = lead.lead + ".";
        const restText = lead.rest;

        const leadW = measureText(arialNarrow, leadText + " ", FONT_SIZE);
        const maxFirst = Math.max(10, MAX_W - leadW);

        const restLines = wrapWords(arialNarrow, restText, FONT_SIZE, maxFirst);

        ensureSpace(restLines.length + 1);

        drawBold(page, arialNarrow, leadText, M_LEFT, y, FONT_SIZE);
        drawUnderline(page, M_LEFT, y, measureText(arialNarrow, leadText, FONT_SIZE));

        const firstRest = restLines[0] || "";
        page.drawText(" " + firstRest, {
          x: M_LEFT + measureText(arialNarrow, leadText, FONT_SIZE),
          y,
          size: FONT_SIZE,
          font: arialNarrow
        });
        y -= LINE_H;

        for (let i=1;i<restLines.length;i++){
          drawLine(restLines[i], M_LEFT, false);
        }

        blankLine();
        continue;
      }

      const lines = wrapWords(arialNarrow, ptxt, FONT_SIZE, MAX_W);
      ensureSpace(lines.length + 1);
      for (const ln of lines){
        drawLine(ln, M_LEFT, false);
      }
      blankLine();
    }

    const totalPages = pages.length;
    for (let i=0;i<totalPages;i++){
      drawHeaderFooter(i, totalPages);
    }

    const out = await pdfDoc.save();
    return new Uint8Array(out);
  }

  function setIframePdf(frameEl, bytes){
    try{
      const blob = new Blob([bytes], { type:"application/pdf" });
      const url = URL.createObjectURL(blob);
      frameEl.src = url;
      setTimeout(() => { try{ URL.revokeObjectURL(url); } catch{} }, 600000);
    } catch {}
  }

  window.carbyne_masterserviceagreement_page_mount = async function(args){
    const root = args && args.root ? args.root : document;
    const referenceNumber = args && args.referenceNumber ? args.referenceNumber : "";

    const frame = root.querySelector("#msaFrame");
    const signBtn = root.querySelector("#msaSignBtn");

    let done = false;

    function safeDisable(){ try{ if (signBtn) signBtn.disabled = true; } catch {} }
    function safeEnable(){ try{ if (signBtn) signBtn.disabled = false; } catch {} }

    safeDisable();
    setStatus(root, "Loading agreement…");

    try{
      const [txt, fontBytes] = await Promise.all([
        fetchText(AGREEMENT_TXT_URL),
        fetchBytes(ARIAL_NARROW_TTF_URL)
      ]);

      const pdfBytes = await buildAgreementPdfBytes(referenceNumber, txt, fontBytes);

      if (frame) setIframePdf(frame, pdfBytes);

      try{
        const b64 = bytesToB64(pdfBytes);
        window.dispatchEvent(new CustomEvent("carbyne:pdfdoc:upsert", {
          detail: {
            id: DOC_ID,
            title: DOC_TITLE,
            b64: b64,
            meta: {
              referenceNumber: referenceNumber || "",
              createdAt: stamp()
            }
          }
        }));
      } catch {}

      setStatus(root, "Ready", "good");
      safeEnable();

    } catch (e){
      setStatus(root, "Unable to load agreement.", "bad");
      safeDisable();
      console.error("MSA load error:", e);
    }

    function onSign(){
      if (done) return;
      window.dispatchEvent(new CustomEvent("carbyne:agreement:sign", {
        detail: { id: DOC_ID, title: DOC_TITLE, referenceNumber: referenceNumber || "" }
      }));
    }

    try{ if (signBtn) signBtn.addEventListener("click", onSign); } catch {}

    return function unmount(){
      done = true;
      try{ if (signBtn) signBtn.removeEventListener("click", onSign); } catch {}
      try{ if (frame) frame.src = "about:blank"; } catch {}
    };
  };
})();
</script>

</body>
</html>

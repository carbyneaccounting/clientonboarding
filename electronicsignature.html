<!-- electronicsignature.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Electronic Signature</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<template id="carbyne_electronic_signature">
  <style>
    .es-wrap{width:100%}
    .es-header{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:0 2px 7px;margin-bottom:7px}
    .es-title{margin:0;font-size:18px;font-weight:950;color:#0b2f4e;letter-spacing:.2px}
    .es-header-actions{display:flex;align-items:center;gap:6px}
    .es-mode-toggle{display:flex;gap:5px;margin-right:7px}

    .es-pill{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;color:#0f172a;
      font-weight:900;font-size:11px;
      padding:6px 11px;border-radius:999px;
      cursor:pointer;transition:all .12s ease;white-space:nowrap;
    }
    .es-pill.primary{background:rgba(0,48,91,.08);border-color:rgba(0,48,91,.18);color:#00305B}
    .es-pill.danger{background:rgba(185,28,28,.06);border-color:rgba(185,28,28,.20);color:#b91c1c}
    .es-pill:hover{transform:translateY(-1px);opacity:.96}
    .es-pill.active{background:rgba(0,48,91,.14);border-color:rgba(0,48,91,.28)}

    .es-main{display:grid;grid-template-columns:1.55fr .45fr;gap:9px}

    .es-card{
      background:#fff;border:1px solid rgba(0,0,0,.10);
      border-radius:10px;box-shadow:0 6px 13px rgba(2,6,23,.08);
      overflow:hidden;
    }

    .es-card-h{
      padding:6px 9px;border-bottom:1px solid rgba(0,0,0,.08);
      font-size:11px;font-weight:950;color:#0f172a;opacity:.90;
      display:flex;align-items:center;justify-content:space-between;
    }

    .es-canvas-area{padding:9px}
    canvas{
      width:100%;height:135px;border:1px solid rgba(0,0,0,.14);
      border-radius:8px;background:#fff;display:block;touch-action:none;
    }

    .es-controls{
      padding:6px 9px 9px;display:flex;align-items:center;
      justify-content:space-between;gap:7px;
    }

    .es-slider{display:flex;align-items:center;gap:6px}
    .es-slider label{font-size:10px;font-weight:900;color:#0f172a;opacity:.82}
    .es-slider input{width:85px;height:17px}

    .es-status{font-size:10px;font-weight:900;color:#0f172a;opacity:.75}
    .es-status.good{color:#0a7a3a;opacity:1}
    .es-status.bad{color:#b91c1c;opacity:1}

    .es-type-area{padding:9px}
    .es-type-input{
      width:100%;border:1px solid rgba(0,0,0,.14);
      border-radius:8px;padding:8px 11px;font-size:13px;font-weight:900;
      outline:none;background:#fff;box-shadow:0 6px 13px rgba(2,6,23,.08);
      color:#0f172a;
    }
    .es-type-preview{
      margin-top:6px;border:1px dashed rgba(0,0,0,.18);
      border-radius:8px;padding:9px;min-height:40px;display:flex;
      align-items:center;justify-content:center;background:rgba(0,0,0,.02);
    }
    .es-script{
      font-family:"Arial Narrow","Arial","system-ui",-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      font-weight:900;font-size:18px;color:#0f172a;line-height:1;user-select:none;white-space:nowrap;
    }
    .es-type-controls{padding-top:6px;display:flex;justify-content:flex-end}

    .es-sidebar{display:flex;flex-direction:column;gap:9px}

    .es-info{padding:9px}
    .es-info-grid{display:grid;grid-template-columns:1fr;gap:6px;margin-top:6px}
    .es-info-item{border:1px solid rgba(0,0,0,.10);border-radius:8px;padding:6px 8px;background:#fff}
    .es-info-label{font-size:8px;font-weight:900;color:#0f172a;opacity:.65;text-transform:uppercase;letter-spacing:.3px}
    .es-info-value{margin-top:2px;font-size:11px;font-weight:900;color:#0f172a}

    .es-adopted-area{padding:9px}
    .es-adopted-box{
      border:1px dashed rgba(0,0,0,.18);
      border-radius:8px;background:rgba(0,0,0,.02);
      min-height:58px;display:flex;align-items:center;justify-content:center;
      padding:6px;overflow:hidden;
    }
    .es-adopted-img{max-width:100%;max-height:52px;display:block}
    .es-adopted-empty{font-size:10px;font-weight:900;color:#334155;opacity:.80}

    @media (max-width:900px){ .es-main{grid-template-columns:1fr} }
  </style>

  <div class="es-wrap" id="esRoot">
    <div class="es-header">
      <h2 class="es-title">Electronic Signature</h2>
      <div class="es-header-actions">
        <div class="es-mode-toggle">
          <button class="es-pill active" id="esModeDraw" type="button">Draw</button>
          <button class="es-pill" id="esModeType" type="button">Type</button>
        </div>
        <button class="es-pill danger" id="esClearTop" type="button">Clear</button>
        <button class="es-pill primary" id="esAdoptTop" type="button">Adopt</button>
      </div>
    </div>

    <div class="es-main">
      <div class="es-card">
        <div class="es-card-h">
          <span>Signature Input</span>
          <span class="es-status" id="esDrawStatus">Empty</span>
        </div>

        <div class="es-canvas-area" id="esDrawWrap">
          <canvas id="esCanvas"></canvas>
          <div class="es-controls">
            <div class="es-slider">
              <label for="esStroke">Stroke</label>
              <input id="esStroke" type="range" min="1" max="8" value="3">
            </div>
            <button class="es-pill danger" id="esClearDraw" type="button">Clear</button>
          </div>
        </div>

        <div class="es-type-area" id="esTypeWrap" style="display:none;">
          <input class="es-type-input" id="esTypeInput" type="text" placeholder="Type your name">
          <div class="es-type-preview">
            <div class="es-script" id="esTypePreview"></div>
          </div>
          <div class="es-type-controls">
            <button class="es-pill danger" id="esClearType" type="button">Clear</button>
          </div>
        </div>
      </div>

      <div class="es-sidebar">
        <div class="es-card">
          <div class="es-card-h">Status</div>
          <div class="es-info">
            <div class="es-info-grid">
              <div class="es-info-item"><div class="es-info-label">Mode</div><div class="es-info-value" id="esModeVal">Draw</div></div>
              <div class="es-info-item"><div class="es-info-label">Ready</div><div class="es-info-value" id="esHasVal">No</div></div>
              <div class="es-info-item"><div class="es-info-label">Adopt</div><div class="es-info-value" id="esAdoptVal">No</div></div>
              <div class="es-info-item"><div class="es-info-label">Time</div><div class="es-info-value" id="esLastVal">—</div></div>
            </div>
          </div>
        </div>

        <div class="es-card">
          <div class="es-card-h">Adopted</div>
          <div class="es-adopted-area">
            <div class="es-adopted-box" id="esAdoptedBox">
              <div class="es-adopted-empty" id="esAdoptedEmpty">None</div>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>
</template>

<script>
  (function(){
    const SIG_KEY = "carbyne_adopted_signature_dataurl";
    const SIG_META_KEY = "carbyne_adopted_signature_meta";

    const PDF_PACKET_KEY = "carbyne_pdf_packet_items";
    const PDF_PACKET_MERGED_KEY = "carbyne_pdf_packet_merged";

    const PUBLIC_IP_KEY = "carbyne_public_ip";

    function nowStamp(){
      const d = new Date();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const yy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
    }

    function auditStamp(){
      const d = new Date();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const yy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      const ss = String(d.getSeconds()).padStart(2,"0");
      return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi + ":" + ss;
    }

    async function getPublicIPCached(){
      let existing = "";
      try{ existing = sessionStorage.getItem(PUBLIC_IP_KEY) || ""; } catch {}
      if (existing) return existing;

      const controller = new AbortController();
      const t = setTimeout(()=>controller.abort(), 3500);
      try{
        const res = await fetch("https://api.ipify.org?format=json", { signal: controller.signal, cache: "no-store" });
        const j = await res.json();
        const ip = (j && j.ip) ? String(j.ip) : "";
        if (ip){
          try{ sessionStorage.setItem(PUBLIC_IP_KEY, ip); } catch {}
          return ip;
        }
      } catch {}
      finally{ clearTimeout(t); }

      return "Unavailable (client-side)";
    }

    function safeJsonParse(s, fallback){
      try{ return JSON.parse(s); } catch { return fallback; }
    }

    function bytesToBase64(u8){
      let bin = "";
      const chunk = 0x8000;
      for (let i=0;i<u8.length;i+=chunk){
        bin += String.fromCharCode.apply(null, u8.subarray(i,i+chunk));
      }
      return btoa(bin);
    }

    function getPacketItems(){
      try{
        const raw = sessionStorage.getItem(PDF_PACKET_KEY) || "";
        const parsed = safeJsonParse(raw, []);
        return Array.isArray(parsed) ? parsed : [];
      } catch {}
      try{
        const raw2 = localStorage.getItem(PDF_PACKET_KEY) || "";
        const parsed2 = safeJsonParse(raw2, []);
        return Array.isArray(parsed2) ? parsed2 : [];
      } catch {}
      return [];
    }

    function setPacketItems(items){
      const payload = JSON.stringify(items || []);
      try{ sessionStorage.setItem(PDF_PACKET_KEY, payload); }
      catch { try{ localStorage.setItem(PDF_PACKET_KEY, payload); } catch {} }
    }

    function setMergedPdfB64(b64){
      try{ sessionStorage.setItem(PDF_PACKET_MERGED_KEY, b64); }
      catch { try{ localStorage.setItem(PDF_PACKET_MERGED_KEY, b64); } catch {} }
    }

    function addOrReplacePacketItem(item){
      const items = getPacketItems()
        .filter(x => x && x.id !== item.id && x.title !== item.title);

      items.push(item);
      setPacketItems(items);
    }

    function wrapTextToWidth(text, font, size, maxWidth){
      const out = [];
      const raw = (text || "").toString();
      if (!raw) return [""];
      const lines = raw.split(/\r?\n/);
      for (const line of lines){
        const words = line.split(/\s+/).filter(Boolean);
        if (!words.length){ out.push(""); continue; }
        let cur = words[0];
        for (let i=1;i<words.length;i++){
          const next = cur + " " + words[i];
          const w = font.widthOfTextAtSize(next, size);
          if (w <= maxWidth) cur = next;
          else { out.push(cur); cur = words[i]; }
        }
        out.push(cur);
      }
      return out;
    }

    async function mergeAllPacketPdfs(){
      const PDFLib = window.PDFLib;
      if (!PDFLib || !PDFLib.PDFDocument) return;

      const items = getPacketItems().filter(x => x && x.bytesB64);
      if (!items.length) return;

      const merged = await PDFLib.PDFDocument.create();
      for (const it of items){
        const srcBytes = Uint8Array.from(atob(it.bytesB64), c => c.charCodeAt(0));
        const src = await PDFLib.PDFDocument.load(srcBytes);
        const pages = await merged.copyPages(src, src.getPageIndices());
        for (const p of pages) merged.addPage(p);
      }
      const out = await merged.save();
      setMergedPdfB64(bytesToBase64(new Uint8Array(out)));
    }

    function clearStored(){
      try{ sessionStorage.removeItem(SIG_KEY); sessionStorage.removeItem(SIG_META_KEY); } catch {}
      try{ localStorage.removeItem(SIG_KEY); localStorage.removeItem(SIG_META_KEY); } catch {}
    }

    function setStored(dataUrl, meta){
      clearStored();
      try{
        sessionStorage.setItem(SIG_KEY, dataUrl);
        sessionStorage.setItem(SIG_META_KEY, JSON.stringify(meta || {}));
      } catch {
        try{
          localStorage.setItem(SIG_KEY, dataUrl);
          localStorage.setItem(SIG_META_KEY, JSON.stringify(meta || {}));
        } catch {}
      }
    }

    function getStored(){
      let dataUrl = "";
      let meta = {};
      try{
        dataUrl = sessionStorage.getItem(SIG_KEY) || "";
        meta = JSON.parse(sessionStorage.getItem(SIG_META_KEY) || "{}");
      } catch {}
      if (!dataUrl){
        try{
          dataUrl = localStorage.getItem(SIG_KEY) || "";
          meta = JSON.parse(localStorage.getItem(SIG_META_KEY) || "{}");
        } catch {}
      }
      return { dataUrl, meta };
    }

    function setAdoptedUI(root, dataUrl){
      const box = root.querySelector("#esAdoptedBox");
      if (!box) return;

      box.innerHTML = "";
      if (!dataUrl){
        const d = document.createElement("div");
        d.className = "es-adopted-empty";
        d.textContent = "None";
        box.appendChild(d);
        return;
      }

      const img = document.createElement("img");
      img.className = "es-adopted-img";
      img.alt = "Adopted signature";
      img.src = dataUrl;
      box.appendChild(img);
    }

    function resizeCanvasToCSS(canvas){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      return dpr;
    }

    function getPoint(e, canvas){
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const x = (clientX - rect.left);
      const y = (clientY - rect.top);
      return { x, y };
    }

    function renderStatus(root, mode, hasSig, adoptEnabled, last){
      root.querySelector("#esModeVal").textContent = mode;
      root.querySelector("#esHasVal").textContent = hasSig ? "Yes" : "No";
      root.querySelector("#esAdoptVal").textContent = adoptEnabled ? "Yes" : "No";
      root.querySelector("#esLastVal").textContent = last || "—";
    }

    function normalizeTypedSig(name){
      const t = (name || "").toString().trim();
      if (!t) return "";
      if (/^\/s\//i.test(t)) return "/s/ " + t.replace(/^\/s\/\s*/i,"").trim();
      return "/s/ " + t;
    }

    async function buildSignaturePdf(referenceNumber, stored){
      const PDFLib = window.PDFLib;
      if (!PDFLib || !PDFLib.PDFDocument) throw new Error("pdf-lib missing");

      const ip = await getPublicIPCached();

      const pdf = await PDFLib.PDFDocument.create();
      const page = pdf.addPage([612, 792]);
      const { width, height } = page.getSize();

      const helv = await pdf.embedFont(PDFLib.StandardFonts.Helvetica);
      const helvBold = await pdf.embedFont(PDFLib.StandardFonts.HelveticaBold);

      const baseSize = 10;
      const line = 12;

      const marginL = 44;
      const marginR = 44;
      const top = height - 54;
      const maxW = width - marginL - marginR;

      let y = top;

      page.drawText("Electronic Signature", { x: marginL, y, size: 16, font: helvBold });
      y -= 20;

      page.drawText("Reference Number: " + (referenceNumber || ""), { x: marginL, y, size: 10, font: helv });
      y -= 18;

      const meta = stored && stored.meta ? stored.meta : {};
      const mode = meta.mode || "";
      const last = meta.lastAdopted || "";

      page.drawText("Signature", { x: marginL, y, size: 12, font: helvBold });
      y -= 16;

      if ((mode || "").toLowerCase() === "type"){
        const typed = normalizeTypedSig(meta.typedTextRaw || meta.typedText || "");
        page.drawText(typed || "—", { x: marginL, y, size: 10, font: helvBold });
        y -= 18;
      } else {
        if (stored && stored.dataUrl){
          const pngBytes = await fetch(stored.dataUrl).then(r=>r.arrayBuffer());
          const png = await pdf.embedPng(pngBytes);
          const sigW = Math.min(420, png.width);
          const scale = sigW / png.width;
          const sigH = png.height * scale;

          const boxH = 90;
          const yTop = y;

          page.drawRectangle({
            x: marginL, y: yTop - boxH, width: maxW, height: boxH,
            borderWidth: 1, borderColor: PDFLib.rgb(0.75,0.75,0.75)
          });

          page.drawImage(png, {
            x: marginL + 10,
            y: (yTop - boxH) + (boxH - sigH) / 2,
            width: png.width * scale,
            height: sigH
          });

          y = yTop - boxH - 10;
        } else {
          page.drawText("—", { x: marginL, y, size: baseSize, font: helv });
          y -= 18;
        }
      }

      y -= 6;
      page.drawText("Audit Log", { x: marginL, y, size: 12, font: helvBold });
      y -= 14;

      const auditLines = [
        "Event: Signature Adopted",
        "Timestamp: " + auditStamp(),
        "Reference Number: " + (referenceNumber || ""),
        "Mode: " + (mode || ""),
        "Adopted Time: " + (last || ""),
        "Timezone: " + (Intl.DateTimeFormat().resolvedOptions().timeZone || ""),
        "User Agent: " + (navigator.userAgent || ""),
        "Public IP: " + ip
      ];

      for (const ln of auditLines){
        const wrapped = wrapTextToWidth(ln, helv, baseSize, maxW);
        for (const w of wrapped){
          page.drawText(w, { x: marginL, y, size: baseSize, font: helv });
          y -= line;
        }
        y -= 1;
      }

      const bytes = await pdf.save();
      return new Uint8Array(bytes);
    }

    window.carbyne_electronic_signature_mount = function(args){
      const root = args && args.root ? args.root : document;
      const referenceNumber = args && args.referenceNumber ? args.referenceNumber : "";

      const canvas = root.querySelector("#esCanvas");
      const ctx = canvas.getContext("2d");
      const stroke = root.querySelector("#esStroke");
      const drawStatus = root.querySelector("#esDrawStatus");

      const modeDrawBtn = root.querySelector("#esModeDraw");
      const modeTypeBtn = root.querySelector("#esModeType");
      const drawWrap = root.querySelector("#esDrawWrap");
      const typeWrap = root.querySelector("#esTypeWrap");

      const typeInput = root.querySelector("#esTypeInput");
      const typePreview = root.querySelector("#esTypePreview");

      const clearTop = root.querySelector("#esClearTop");
      const adoptTop = root.querySelector("#esAdoptTop");
      const clearDraw = root.querySelector("#esClearDraw");
      const clearType = root.querySelector("#esClearType");

      let mode = "Draw";
      let drawing = false;
      let hasDrawInk = false;
      let hasTypeInk = false;

      function setMode(next){
        if (mode === next) return;

        if (next === "Draw"){
          typeInput.value = "";
          typePreview.textContent = "";
          hasTypeInk = false;
        } else {
          clearCanvas();
          hasDrawInk = false;
        }

        mode = next;
        modeDrawBtn.classList.toggle("active", mode === "Draw");
        modeTypeBtn.classList.toggle("active", mode === "Type");

        drawWrap.style.display = (mode === "Draw") ? "" : "none";
        typeWrap.style.display = (mode === "Type") ? "" : "none";

        refreshUI();
      }

      function clearCanvas(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        hasDrawInk = false;
        drawStatus.textContent = "Empty";
        drawStatus.classList.remove("good");
        drawStatus.classList.add("bad");
      }

      function markDrawHasInk(){
        hasDrawInk = true;
        drawStatus.textContent = "Ready";
        drawStatus.classList.remove("bad");
        drawStatus.classList.add("good");
      }

      function currentHasSignature(){
        return (mode === "Draw") ? hasDrawInk : hasTypeInk;
      }

      function refreshUI(){
        const hasSig = currentHasSignature();
        adoptTop.disabled = !hasSig;

        const stored = getStored();
        const last = stored.meta && stored.meta.lastAdopted ? stored.meta.lastAdopted : "—";
        renderStatus(root, mode, hasSig, hasSig, last);

        setAdoptedUI(root, stored.dataUrl || "");
      }

      async function writeSignaturePdfToPacket(stored){
        const PDFLib = window.PDFLib;
        if (!PDFLib || !PDFLib.PDFDocument) return;

        const bytesU8 = await buildSignaturePdf(referenceNumber, stored);
        const item = {
          id: "electronic_signature",
          title: "Electronic Signature",
          referenceNumber: referenceNumber || "",
          createdAt: Date.now(),
          bytesB64: bytesToBase64(bytesU8)
        };

        addOrReplacePacketItem(item);
        await mergeAllPacketPdfs();

        window.dispatchEvent(new CustomEvent("carbyne:pdf:updated", { detail: { id: item.id } }));
      }

      async function adopt(){
        if (!currentHasSignature()) return;

        let dataUrl = "";
        let meta = { mode, lastAdopted: nowStamp() };

        if (mode === "Draw"){
          dataUrl = canvas.toDataURL("image/png");
        } else {
          const name = (typeInput.value || "").trim();
          const sig = normalizeTypedSig(name);
          meta.typedTextRaw = name;
          meta.typedText = sig;

          const off = document.createElement("canvas");
          off.width = 900;
          off.height = 220;
          const octx = off.getContext("2d");
          octx.clearRect(0,0,off.width,off.height);
          octx.fillStyle = "#ffffff";
          octx.fillRect(0,0,off.width,off.height);

          octx.fillStyle = "#0f172a";
          octx.textAlign = "center";
          octx.textBaseline = "middle";
          octx.font = "bold 56px Arial Narrow, Arial, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
          octx.fillText(sig, off.width/2, off.height/2);

          dataUrl = off.toDataURL("image/png");
        }

        setStored(dataUrl, meta);
        refreshUI();

        const stored = getStored();
        await writeSignaturePdfToPacket(stored);

        window.dispatchEvent(new CustomEvent("carbyne:signature:adopted", { detail: { dataUrl, meta } }));
      }

      function clearAll(){
        clearStored();
        clearCanvas();
        typeInput.value = "";
        typePreview.textContent = "";
        hasTypeInk = false;
        refreshUI();
      }

      function onTypeInput(){
        const raw = (typeInput.value || "").trim();
        const val = normalizeTypedSig(raw);
        typePreview.textContent = val;
        hasTypeInk = !!raw;
        refreshUI();
      }

      function startDraw(e){
        if (mode !== "Draw") return;
        drawing = true;

        resizeCanvasToCSS(canvas);

        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "#0f172a";
        ctx.lineWidth = parseInt(stroke.value || "3",10) * (window.devicePixelRatio || 1);

        const p = getPoint(e, canvas);
        const dpr = window.devicePixelRatio || 1;
        ctx.beginPath();
        ctx.moveTo(p.x * dpr, p.y * dpr);

        e.preventDefault();
      }

      function moveDraw(e){
        if (!drawing || mode !== "Draw") return;
        const p = getPoint(e, canvas);
        const dpr = window.devicePixelRatio || 1;
        ctx.lineTo(p.x * dpr, p.y * dpr);
        ctx.stroke();
        markDrawHasInk();
        refreshUI();
        e.preventDefault();
      }

      function endDraw(){
        if (mode !== "Draw") return;
        drawing = false;
      }

      function onResize(){
        if (mode !== "Draw") return;
        const prev = canvas.toDataURL("image/png");
        resizeCanvasToCSS(canvas);
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = prev;
      }

      function init(){
        resizeCanvasToCSS(canvas);
        drawStatus.classList.add("bad");

        modeDrawBtn.addEventListener("click", ()=>setMode("Draw"));
        modeTypeBtn.addEventListener("click", ()=>setMode("Type"));

        typeInput.addEventListener("input", onTypeInput);

        clearTop.addEventListener("click", clearAll);
        clearDraw.addEventListener("click", ()=>{ clearCanvas(); refreshUI(); });
        clearType.addEventListener("click", ()=>{
          typeInput.value = "";
          typePreview.textContent = "";
          hasTypeInk = false;
          refreshUI();
        });

        adoptTop.addEventListener("click", ()=>{ adopt(); });

        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", moveDraw);
        window.addEventListener("mouseup", endDraw);

        canvas.addEventListener("touchstart", startDraw, { passive:false });
        canvas.addEventListener("touchmove", moveDraw, { passive:false });
        window.addEventListener("touchend", endDraw);

        window.addEventListener("resize", onResize);

        const stored = getStored();
        if (stored && stored.dataUrl){ setAdoptedUI(root, stored.dataUrl); }

        refreshUI();
      }

      init();

      return function unmount(){
        window.removeEventListener("resize", onResize);
      };
    };
  })();
</script>

</body>
</html>

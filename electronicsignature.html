<!-- electronicsignature.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Electronic Signature</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>

<template id="carbyne_electronic_signature">
  <style>
    .es-wrap{width:100%}
    
    .es-header{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:0 2px 7px;margin-bottom:7px;
    }
    .es-title{
      margin:0;font-size:18px;font-weight:950;color:#0b2f4e;letter-spacing:.2px;
    }
    
    .es-header-actions{display:flex;align-items:center;gap:6px}
    .es-mode-toggle{display:flex;gap:5px;margin-right:7px}
    
    .es-pill{
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      color:#0f172a;
      font-weight:900;
      font-size:11px;
      padding:6px 11px;
      border-radius:999px;
      cursor:pointer;
      transition:all .12s ease;
      white-space:nowrap;
    }
    .es-pill.primary{background:rgba(0,48,91,.08);border-color:rgba(0,48,91,.18);color:#00305B}
    .es-pill.danger{background:rgba(185,28,28,.06);border-color:rgba(185,28,28,.20);color:#b91c1c}
    .es-pill:hover{transform:translateY(-1px);opacity:.96}
    .es-pill.active{background:rgba(0,48,91,.14);border-color:rgba(0,48,91,.28)}

    .es-main{
      display:grid;
      grid-template-columns:1.55fr .45fr;
      gap:9px;
    }

    .es-card{
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:10px;
      box-shadow:0 6px 13px rgba(2,6,23,.08);
      overflow:hidden;
    }

    .es-card-h{
      padding:6px 9px;
      border-bottom:1px solid rgba(0,0,0,.08);
      font-size:11px;
      font-weight:950;
      color:#0f172a;
      opacity:.90;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }

    .es-canvas-area{padding:9px}
    canvas{
      width:100%;
      height:135px;
      border:1px solid rgba(0,0,0,.14);
      border-radius:8px;
      background:#fff;
      display:block;
      touch-action:none;
    }

    .es-controls{
      padding:6px 9px 9px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:7px;
    }

    .es-slider{display:flex;align-items:center;gap:6px}
    .es-slider label{font-size:10px;font-weight:900;color:#0f172a;opacity:.82}
    .es-slider input{width:85px;height:17px}

    .es-status{font-size:10px;font-weight:900;color:#0f172a;opacity:.75}
    .es-status.good{color:#0a7a3a;opacity:1}
    .es-status.bad{color:#b91c1c;opacity:1}

    .es-type-area{padding:9px}
    .es-type-input{
      width:100%;
      border:1px solid rgba(0,0,0,.14);
      border-radius:8px;
      padding:8px 11px;
      font-size:13px;
      font-weight:900;
      outline:none;
      background:#fff;
      box-shadow:0 6px 13px rgba(2,6,23,.08);
      color:#0f172a;
    }
    .es-type-preview{
      margin-top:6px;
      border:1px dashed rgba(0,0,0,.18);
      border-radius:8px;
      padding:9px;
      min-height:40px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.02);
    }
    .es-script{
      font-family:"Brush Script MT","Segoe Script","Snell Roundhand","Apple Chancery",cursive;
      font-size:26px;
      color:#0f172a;
      line-height:1;
      user-select:none;
      white-space:nowrap;
    }
    .es-type-controls{padding-top:6px;display:flex;justify-content:flex-end}

    .es-sidebar{display:flex;flex-direction:column;gap:9px}

    .es-info{padding:9px}
    .es-info-grid{
      display:grid;
      grid-template-columns:1fr;
      gap:6px;
      margin-top:6px;
    }
    .es-info-item{
      border:1px solid rgba(0,0,0,.10);
      border-radius:8px;
      padding:6px 8px;
      background:#fff;
    }
    .es-info-label{font-size:8px;font-weight:900;color:#0f172a;opacity:.65;text-transform:uppercase;letter-spacing:.3px}
    .es-info-value{margin-top:2px;font-size:11px;font-weight:900;color:#0f172a}

    .es-adopted-area{padding:9px}
    .es-adopted-box{
      border:1px dashed rgba(0,0,0,.18);
      border-radius:8px;
      background:rgba(0,0,0,.02);
      min-height:58px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      overflow:hidden;
    }
    .es-adopted-img{max-width:100%;max-height:52px;display:block}
    .es-adopted-empty{font-size:10px;font-weight:900;color:#334155;opacity:.80}

    @media (max-width:900px){
      .es-main{grid-template-columns:1fr}
    }
  </style>

  <div class="es-wrap" id="esRoot">
    <div class="es-header">
      <h2 class="es-title">Electronic Signature</h2>
      <div class="es-header-actions">
        <div class="es-mode-toggle">
          <button class="es-pill active" id="esModeDraw" type="button">Draw</button>
          <button class="es-pill" id="esModeType" type="button">Type</button>
        </div>
        <button class="es-pill danger" id="esClearTop" type="button">Clear</button>
        <button class="es-pill primary" id="esAdoptTop" type="button">Adopt</button>
      </div>
    </div>

    <div class="es-main">
      <div class="es-card">
        <div class="es-card-h">
          <span>Signature Input</span>
          <span class="es-status" id="esDrawStatus">Empty</span>
        </div>

        <div class="es-canvas-area" id="esDrawWrap">
          <canvas id="esCanvas"></canvas>
          <div class="es-controls">
            <div class="es-slider">
              <label for="esStroke">Stroke</label>
              <input id="esStroke" type="range" min="1" max="8" value="3">
            </div>
            <button class="es-pill danger" id="esClearDraw" type="button">Clear</button>
          </div>
        </div>

        <div class="es-type-area" id="esTypeWrap" style="display:none;">
          <input class="es-type-input" id="esTypeInput" type="text" placeholder="Type your name">
          <div class="es-type-preview">
            <div class="es-script" id="esTypePreview"></div>
          </div>
          <div class="es-type-controls">
            <button class="es-pill danger" id="esClearType" type="button">Clear</button>
          </div>
        </div>
      </div>

      <div class="es-sidebar">
        <div class="es-card">
          <div class="es-card-h">Status</div>
          <div class="es-info">
            <div class="es-info-grid">
              <div class="es-info-item">
                <div class="es-info-label">Mode</div>
                <div class="es-info-value" id="esModeVal">Draw</div>
              </div>
              <div class="es-info-item">
                <div class="es-info-label">Ready</div>
                <div class="es-info-value" id="esHasVal">No</div>
              </div>
              <div class="es-info-item">
                <div class="es-info-label">Adopt</div>
                <div class="es-info-value" id="esAdoptVal">No</div>
              </div>
              <div class="es-info-item">
                <div class="es-info-label">Time</div>
                <div class="es-info-value" id="esLastVal">—</div>
              </div>
            </div>
          </div>
        </div>

        <div class="es-card">
          <div class="es-card-h">Adopted</div>
          <div class="es-adopted-area">
            <div class="es-adopted-box" id="esAdoptedBox">
              <div class="es-adopted-empty" id="esAdoptedEmpty">None</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  (function(){
    const SIG_KEY = "carbyne_adopted_signature_dataurl";
    const SIG_META_KEY = "carbyne_adopted_signature_meta";

    const PDF_PACKET_KEY = "carbyne_pdf_packet_items";
    const PDF_PACKET_MERGED_KEY = "carbyne_pdf_packet_merged";
    const PDF_PACKET_META_KEY = "carbyne_pdf_packet_meta";
    const PDF_DOC_ID_SIGNATURE = "signature_page";

    function nowStamp(){
      const d = new Date();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const yy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      return mm + "/" + dd + "/" + yy + " " + hh + ":" + mi;
    }

    function nowIso(){
      try{ return new Date().toISOString(); } catch { return ""; }
    }

    function safeJsonParse(s, fallback){
      try{ return JSON.parse(s); } catch { return fallback; }
    }

    function clearStored(){
      try{ sessionStorage.removeItem(SIG_KEY); sessionStorage.removeItem(SIG_META_KEY); } catch {}
      try{ localStorage.removeItem(SIG_KEY); localStorage.removeItem(SIG_META_KEY); } catch {}
    }

    function setStored(dataUrl, meta){
      clearStored();
      try{
        sessionStorage.setItem(SIG_KEY, dataUrl);
        sessionStorage.setItem(SIG_META_KEY, JSON.stringify(meta || {}));
      } catch {
        try{
          localStorage.setItem(SIG_KEY, dataUrl);
          localStorage.setItem(SIG_META_KEY, JSON.stringify(meta || {}));
        } catch {}
      }
    }

    function getStored(){
      let dataUrl = "";
      let meta = {};
      try{
        dataUrl = sessionStorage.getItem(SIG_KEY) || "";
        meta = JSON.parse(sessionStorage.getItem(SIG_META_KEY) || "{}");
      } catch {}
      if (!dataUrl){
        try{
          dataUrl = localStorage.getItem(SIG_KEY) || "";
          meta = JSON.parse(localStorage.getItem(SIG_META_KEY) || "{}");
        } catch {}
      }
      return { dataUrl, meta };
    }

    function setAdoptedUI(root, dataUrl){
      const box = root.querySelector("#esAdoptedBox");
      if (!box) return;

      box.innerHTML = "";
      if (!dataUrl){
        const d = document.createElement("div");
        d.className = "es-adopted-empty";
        d.textContent = "None";
        box.appendChild(d);
        return;
      }

      const img = document.createElement("img");
      img.className = "es-adopted-img";
      img.alt = "Adopted signature";
      img.src = dataUrl;
      box.appendChild(img);
    }

    function resizeCanvasToCSS(canvas){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
      return dpr;
    }

    function getPoint(e, canvas){
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const x = (clientX - rect.left);
      const y = (clientY - rect.top);
      return { x, y };
    }

    function renderStatus(root, mode, hasSig, adoptEnabled, last){
      root.querySelector("#esModeVal").textContent = mode;
      root.querySelector("#esHasVal").textContent = hasSig ? "Yes" : "No";
      root.querySelector("#esAdoptVal").textContent = adoptEnabled ? "Yes" : "No";
      root.querySelector("#esLastVal").textContent = last || "—";
    }

    function uint8ToBase64(u8){
      let s = "";
      const chunk = 0x8000;
      for (let i=0;i<u8.length;i+=chunk){
        s += String.fromCharCode.apply(null, u8.subarray(i, i+chunk));
      }
      return btoa(s);
    }

    function base64ToUint8(b64){
      const bin = atob(b64);
      const len = bin.length;
      const u8 = new Uint8Array(len);
      for (let i=0;i<len;i++) u8[i] = bin.charCodeAt(i);
      return u8;
    }

    function dataUrlToUint8(dataUrl){
      const idx = (dataUrl || "").indexOf(",");
      if (idx < 0) return new Uint8Array();
      const b64 = dataUrl.slice(idx+1);
      return base64ToUint8(b64);
    }

    function getPacketItems(){
      try{
        const raw = sessionStorage.getItem(PDF_PACKET_KEY) || "";
        const parsed = safeJsonParse(raw, []);
        return Array.isArray(parsed) ? parsed : [];
      } catch {}
      try{
        const raw2 = localStorage.getItem(PDF_PACKET_KEY) || "";
        const parsed2 = safeJsonParse(raw2, []);
        return Array.isArray(parsed2) ? parsed2 : [];
      } catch {}
      return [];
    }

    function setPacketItems(items){
      try{
        sessionStorage.setItem(PDF_PACKET_KEY, JSON.stringify(items || []));
      } catch {
        try{ localStorage.setItem(PDF_PACKET_KEY, JSON.stringify(items || [])); } catch {}
      }
    }

    function setPacketMeta(meta){
      try{
        sessionStorage.setItem(PDF_PACKET_META_KEY, JSON.stringify(meta || {}));
      } catch {
        try{ localStorage.setItem(PDF_PACKET_META_KEY, JSON.stringify(meta || {})); } catch {}
      }
    }

    function setMergedPdfBytes(u8){
      const b64 = uint8ToBase64(u8);
      try{
        sessionStorage.setItem(PDF_PACKET_MERGED_KEY, b64);
      } catch {
        try{ localStorage.setItem(PDF_PACKET_MERGED_KEY, b64); } catch {}
      }
    }

    function getMergedPdfBytes(){
      try{
        const b64 = sessionStorage.getItem(PDF_PACKET_MERGED_KEY) || "";
        return b64 ? base64ToUint8(b64) : null;
      } catch {}
      try{
        const b64 = localStorage.getItem(PDF_PACKET_MERGED_KEY) || "";
        return b64 ? base64ToUint8(b64) : null;
      } catch {}
      return null;
    }

    async function mergePacketPdfs(items){
      const PDFLib = window.PDFLib;
      if (!PDFLib || !PDFLib.PDFDocument) return null;

      const merged = await PDFLib.PDFDocument.create();
      for (const it of (items || [])){
        if (!it || !it.bytesB64) continue;
        const u8 = base64ToUint8(it.bytesB64);
        const src = await PDFLib.PDFDocument.load(u8);
        const pages = await merged.copyPages(src, src.getPageIndices());
        for (const p of pages) merged.addPage(p);
      }
      const out = await merged.save();
      return new Uint8Array(out);
    }

    function upsertPacketItem(docId, name, bytesU8, meta){
      const items = getPacketItems();
      const b64 = uint8ToBase64(bytesU8);

      const nowTs = Date.now();
      const entry = {
        id: docId,
        name: name || docId,
        bytesB64: b64,
        updatedAt: nowTs
      };

      let replaced = false;
      const out = [];
      for (const it of items){
        if (it && it.id === docId){
          out.push(entry);
          replaced = true;
        } else {
          out.push(it);
        }
      }
      if (!replaced) out.push(entry);

      out.sort((a,b)=> (a.updatedAt||0) - (b.updatedAt||0));

      setPacketItems(out);
      setPacketMeta(meta || {});
      return out;
    }

    function firePacketEvents(detail){
      try{
        window.dispatchEvent(new CustomEvent("carbyne:pdf:packet:updated", { detail: detail || {} }));
      } catch {}
      try{
        window.dispatchEvent(new CustomEvent("carbyne:pdf:upsert", { detail: detail || {} }));
      } catch {}
    }

    async function fetchPublicIp(timeoutMs){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), Math.max(250, timeoutMs || 1200));
      try{
        const res = await fetch("https://api.ipify.org?format=json", { signal: ctrl.signal, cache: "no-store" });
        if (!res.ok) return "";
        const j = await res.json();
        return (j && j.ip) ? String(j.ip) : "";
      } catch {
        return "";
      } finally {
        clearTimeout(t);
      }
    }

    function guessTimeZone(){
      try{
        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        return tz ? String(tz) : "";
      } catch { return ""; }
    }

    function safeUserAgent(){
      try{ return String(navigator.userAgent || ""); } catch { return ""; }
    }

    async function buildSignaturePdf(opts){
      const PDFLib = window.PDFLib;
      if (!PDFLib || !PDFLib.PDFDocument) return null;

      const { dataUrl, referenceNumber, adoptedAtDisplay, adoptedAtIso, mode, typedText, evidence } = opts || {};

      const pdfDoc = await PDFLib.PDFDocument.create();
      const page = pdfDoc.addPage([612, 792]); // Letter

      const helv = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
      const helvBold = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);

      const fontBody = helv;
      const fontHead = helvBold;

      const marginL = 48;
      const marginR = 48;
      const top = 740;

      const bodySize = 10;
      const headSize = 12;
      const line = 11;

      const textColor = PDFLib.rgb(0.06, 0.09, 0.16);

      page.drawText("Electronic Signature", {
        x: marginL,
        y: top,
        size: headSize,
        font: fontHead,
        color: textColor
      });

      const subY = top - 18;
      page.drawText("Reference Number: " + (referenceNumber || ""), {
        x: marginL,
        y: subY,
        size: bodySize,
        font: fontBody,
        color: textColor
      });

      page.drawText("Adopted: " + (adoptedAtDisplay || ""), {
        x: marginL,
        y: subY - line,
        size: bodySize,
        font: fontBody,
        color: textColor
      });

      page.drawText("Mode: " + (mode || ""), {
        x: marginL,
        y: subY - (line * 2),
        size: bodySize,
        font: fontBody,
        color: textColor
      });

      if (mode === "Type" && typedText){
        page.drawText("Typed Name: " + typedText, {
          x: marginL,
          y: subY - (line * 3),
          size: bodySize,
          font: fontBody,
          color: textColor
        });
      }

      const boxTop = 620;
      const boxH = 150;
      const boxW = 612 - marginL - marginR;
      const boxX = marginL;
      const boxY = boxTop - boxH;

      page.drawRectangle({
        x: boxX,
        y: boxY,
        width: boxW,
        height: boxH,
        borderWidth: 1,
        borderColor: PDFLib.rgb(0.85,0.87,0.91),
        color: PDFLib.rgb(1,1,1)
      });

      page.drawText("Signature", {
        x: boxX,
        y: boxTop + 8,
        size: bodySize,
        font: fontHead,
        color: textColor
      });

      let sigBytes = null;
      try{ sigBytes = dataUrlToUint8(dataUrl || ""); } catch { sigBytes = null; }

      if (sigBytes && sigBytes.length){
        let img;
        try{
          img = await pdfDoc.embedPng(sigBytes);
        } catch {
          img = null;
        }

        if (img){
          const dims = img.scale(1);
          const maxW = boxW - 24;
          const maxH = boxH - 24;

          let scale = 1;
          if (dims.width > 0 && dims.height > 0){
            const s1 = maxW / dims.width;
            const s2 = maxH / dims.height;
            scale = Math.min(s1, s2, 1);
          }

          const w = dims.width * scale;
          const h = dims.height * scale;

          const x = boxX + ((boxW - w) / 2);
          const y = boxY + ((boxH - h) / 2);

          page.drawImage(img, { x, y, width: w, height: h });
        }
      }

      const evTop = 440;
      page.drawText("Evidence Log", {
        x: marginL,
        y: evTop,
        size: headSize,
        font: fontHead,
        color: textColor
      });

      const ev = evidence || {};
      const rows = [
        ["Event", "Signature Adopted"],
        ["Timestamp (ISO)", adoptedAtIso || ""],
        ["Timestamp (Local)", adoptedAtDisplay || ""],
        ["Public IP", ev.publicIp || "Unavailable"],
        ["User Agent", ev.userAgent || ""],
        ["Time Zone", ev.timeZone || ""]
      ];

      const col1 = 140;
      let y = evTop - 18;
      for (const r of rows){
        page.drawText(String(r[0] || ""), { x: marginL, y, size: bodySize, font: fontHead, color: textColor });
        page.drawText(String(r[1] || ""), { x: marginL + col1, y, size: bodySize, font: fontBody, color: textColor });
        y -= line;
      }

      const footerY = 40;
      page.drawText("Carbyne Accounting™ - Confidential & Proprietary System", {
        x: marginL,
        y: footerY,
        size: 9,
        font: fontBody,
        color: PDFLib.rgb(0.25,0.29,0.36)
      });

      const out = await pdfDoc.save();
      return new Uint8Array(out);
    }

    window.carbyne_electronic_signature_mount = function(args){
      const root = args && args.root ? args.root : document;
      const referenceNumber = (args && args.referenceNumber) ? String(args.referenceNumber) : "";

      const canvas = root.querySelector("#esCanvas");
      const ctx = canvas.getContext("2d");
      const stroke = root.querySelector("#esStroke");
      const drawStatus = root.querySelector("#esDrawStatus");

      const modeDrawBtn = root.querySelector("#esModeDraw");
      const modeTypeBtn = root.querySelector("#esModeType");
      const drawWrap = root.querySelector("#esDrawWrap");
      const typeWrap = root.querySelector("#esTypeWrap");

      const typeInput = root.querySelector("#esTypeInput");
      const typePreview = root.querySelector("#esTypePreview");

      const clearTop = root.querySelector("#esClearTop");
      const adoptTop = root.querySelector("#esAdoptTop");
      const clearDraw = root.querySelector("#esClearDraw");
      const clearType = root.querySelector("#esClearType");

      let mode = "Draw";
      let drawing = false;
      let hasDrawInk = false;
      let hasTypeInk = false;

      function setMode(next){
        if (mode === next) return;

        if (next === "Draw"){
          typeInput.value = "";
          typePreview.textContent = "";
          hasTypeInk = false;
        } else {
          clearCanvas();
          hasDrawInk = false;
        }

        mode = next;
        modeDrawBtn.classList.toggle("active", mode === "Draw");
        modeTypeBtn.classList.toggle("active", mode === "Type");

        drawWrap.style.display = (mode === "Draw") ? "" : "none";
        typeWrap.style.display = (mode === "Type") ? "" : "none";

        refreshUI();
      }

      function clearCanvas(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        hasDrawInk = false;
        drawStatus.textContent = "Empty";
        drawStatus.classList.remove("good");
        drawStatus.classList.add("bad");
      }

      function markDrawHasInk(){
        hasDrawInk = true;
        drawStatus.textContent = "Ready";
        drawStatus.classList.remove("bad");
        drawStatus.classList.add("good");
      }

      function currentHasSignature(){
        return (mode === "Draw") ? hasDrawInk : hasTypeInk;
      }

      function refreshUI(){
        const hasSig = currentHasSignature();
        adoptTop.disabled = !hasSig;

        const stored = getStored();
        const last = stored.meta && stored.meta.lastAdopted ? stored.meta.lastAdopted : "—";
        renderStatus(root, mode, hasSig, hasSig, last);

        setAdoptedUI(root, stored.dataUrl || "");
      }

      async function adopt(){
        if (!currentHasSignature()) return;

        let dataUrl = "";
        let meta = { mode, lastAdopted: nowStamp(), lastAdoptedISO: nowIso() };

        if (mode === "Draw"){
          dataUrl = canvas.toDataURL("image/png");
        } else {
          const off = document.createElement("canvas");
          off.width = 900;
          off.height = 220;
          const octx = off.getContext("2d");
          octx.clearRect(0,0,off.width,off.height);
          octx.fillStyle = "#ffffff";
          octx.fillRect(0,0,off.width,off.height);

          octx.fillStyle = "#0f172a";
          octx.textAlign = "center";
          octx.textBaseline = "middle";
          octx.font = "80px Brush Script MT, Segoe Script, Snell Roundhand, Apple Chancery, cursive";
          octx.fillText((typeInput.value || "").trim(), off.width/2, off.height/2);

          dataUrl = off.toDataURL("image/png");
          meta.typedText = (typeInput.value || "").trim();
        }

        setStored(dataUrl, meta);
        refreshUI();

        const evidence = {
          publicIp: "",
          userAgent: safeUserAgent(),
          timeZone: guessTimeZone()
        };

        evidence.publicIp = await fetchPublicIp(1200);

        const pdfBytes = await buildSignaturePdf({
          dataUrl: dataUrl,
          referenceNumber: referenceNumber,
          adoptedAtDisplay: meta.lastAdopted || "",
          adoptedAtIso: meta.lastAdoptedISO || "",
          mode: meta.mode || mode,
          typedText: meta.typedText || "",
          evidence: evidence
        });

        if (pdfBytes && pdfBytes.length){
          const packetMeta = {
            referenceNumber: referenceNumber,
            updatedAtISO: nowIso(),
            lastUpdatedDocId: PDF_DOC_ID_SIGNATURE
          };

          const items = upsertPacketItem(PDF_DOC_ID_SIGNATURE, "Electronic Signature", pdfBytes, packetMeta);

          let merged = null;
          try{ merged = await mergePacketPdfs(items); } catch { merged = null; }
          if (merged && merged.length){
            setMergedPdfBytes(merged);
          } else {
            setMergedPdfBytes(pdfBytes);
          }

          if (typeof window.carbyne_packet_upsert_pdf === "function"){
            try{
              window.carbyne_packet_upsert_pdf({
                id: PDF_DOC_ID_SIGNATURE,
                name: "Electronic Signature",
                bytes: pdfBytes,
                referenceNumber: referenceNumber,
                meta: packetMeta
              });
            } catch {}
          }

          firePacketEvents({
            id: PDF_DOC_ID_SIGNATURE,
            name: "Electronic Signature",
            referenceNumber: referenceNumber,
            updatedAtISO: packetMeta.updatedAtISO,
            mergedAvailable: !!getMergedPdfBytes()
          });
        }

        window.dispatchEvent(new CustomEvent("carbyne:signature:adopted", { detail: { dataUrl, meta } }));
      }

      function clearAll(){
        clearStored();
        clearCanvas();
        typeInput.value = "";
        typePreview.textContent = "";
        hasTypeInk = false;
        refreshUI();
      }

      function onTypeInput(){
        const val = (typeInput.value || "").trim();
        typePreview.textContent = val;
        hasTypeInk = !!val;
        refreshUI();
      }

      function startDraw(e){
        if (mode !== "Draw") return;
        drawing = true;

        resizeCanvasToCSS(canvas);

        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "#0f172a";
        ctx.lineWidth = parseInt(stroke.value || "3",10) * (window.devicePixelRatio || 1);

        const p = getPoint(e, canvas);
        const dpr = window.devicePixelRatio || 1;
        ctx.beginPath();
        ctx.moveTo(p.x * dpr, p.y * dpr);

        e.preventDefault();
      }

      function moveDraw(e){
        if (!drawing || mode !== "Draw") return;
        const p = getPoint(e, canvas);
        const dpr = window.devicePixelRatio || 1;
        ctx.lineTo(p.x * dpr, p.y * dpr);
        ctx.stroke();
        markDrawHasInk();
        refreshUI();
        e.preventDefault();
      }

      function endDraw(){
        if (mode !== "Draw") return;
        drawing = false;
      }

      function onResize(){
        if (mode !== "Draw") return;
        const prev = canvas.toDataURL("image/png");
        resizeCanvasToCSS(canvas);
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = prev;
      }

      function init(){
        resizeCanvasToCSS(canvas);
        drawStatus.classList.add("bad");

        modeDrawBtn.addEventListener("click", onModeDrawClick);
        modeTypeBtn.addEventListener("click", onModeTypeClick);

        typeInput.addEventListener("input", onTypeInput);

        clearTop.addEventListener("click", clearAll);
        clearDraw.addEventListener("click", onClearDraw);
        clearType.addEventListener("click", onClearType);

        adoptTop.addEventListener("click", adopt);

        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", moveDraw);
        window.addEventListener("mouseup", endDraw);

        canvas.addEventListener("touchstart", startDraw, { passive:false });
        canvas.addEventListener("touchmove", moveDraw, { passive:false });
        window.addEventListener("touchend", endDraw);

        stroke.addEventListener("input", ()=>{});

        window.addEventListener("resize", onResize);

        const stored = getStored();
        if (stored && stored.dataUrl){
          setAdoptedUI(root, stored.dataUrl);
        }

        refreshUI();
      }

      function onModeDrawClick(){ setMode("Draw"); }
      function onModeTypeClick(){ setMode("Type"); }

      function onClearDraw(){
        clearCanvas();
        refreshUI();
      }

      function onClearType(){
        typeInput.value = "";
        typePreview.textContent = "";
        hasTypeInk = false;
        refreshUI();
      }

      init();

      return function unmount(){
        modeDrawBtn.removeEventListener("click", onModeDrawClick);
        modeTypeBtn.removeEventListener("click", onModeTypeClick);

        typeInput.removeEventListener("input", onTypeInput);

        clearTop.removeEventListener("click", clearAll);
        adoptTop.removeEventListener("click", adopt);

        clearDraw.removeEventListener("click", onClearDraw);
        clearType.removeEventListener("click", onClearType);

        canvas.removeEventListener("mousedown", startDraw);
        canvas.removeEventListener("mousemove", moveDraw);
        window.removeEventListener("mouseup", endDraw);

        canvas.removeEventListener("touchstart", startDraw);
        canvas.removeEventListener("touchmove", moveDraw);
        window.removeEventListener("touchend", endDraw);

        window.removeEventListener("resize", onResize);
      };
    };
  })();
</script>

</body>
</html>
